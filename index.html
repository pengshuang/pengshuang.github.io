<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在路上，慢慢走！">
<meta property="og:type" content="website">
<meta property="og:title" content="小沙文的博客">
<meta property="og:url" content="http://pengshuang.space/index.html">
<meta property="og:site_name" content="小沙文的博客">
<meta property="og:description" content="在路上，慢慢走！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小沙文的博客">
<meta name="twitter:description" content="在路上，慢慢走！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://pengshuang.space/"/>

  <title> 小沙文的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小沙文的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/23/Elasticsearch-学习-Java-API-一/" itemprop="url">
                  Elasticsearch 学习: Java API (一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-23T10:51:30+08:00" content="2016-11-23">
              2016-11-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/23/Elasticsearch-学习-Java-API-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/23/Elasticsearch-学习-Java-API-一/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/23/Elasticsearch-学习-Java-API-一/" class="leancloud_visitors" data-flag-title="Elasticsearch 学习: Java API (一)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在学习 Elasticsearch，这是一个分布式的大数据搜索引擎，其实也可以看作是一个分布式的数据库。我使用的 Elasticsearch 的版本是 2.4.1，鉴于网上相关的中文资料较少，所以自己看官方文档学习一下。</p>
<p>使用 Maven 工程，我的 pom 文件如下所示：</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><h3 id="连接机器">连接机器</h3><pre><code><span class="label">TransportClient</span> client = TransportClient.<span class="keyword">builder()
</span>    .<span class="keyword">build()
</span>    .<span class="keyword">addTransportAddress(new </span>InetSocketTransportAddress(InetAddress
    .getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>))<span class="comment">;       </span>
</code></pre><h3 id="Index_API_创建_Index_并且插入_Document">Index API 创建 Index 并且插入 Document</h3><p>创建索引有很多种方法，这里列举常用的 2 种：</p>
<pre><code><span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; json = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();
json.put(<span class="string">"first_name"</span>,<span class="string">"Shuang"</span>);
json.put(<span class="string">"last_name"</span>, <span class="string">"Peng"</span>);
json.put(<span class="string">"age"</span>, <span class="number">24</span>);
json.put(<span class="string">"about"</span>, <span class="string">"I love coding"</span>);
IndexResponse response = client
    .prepareIndex(<span class="string">"tseg"</span>,<span class="string">"students"</span>,<span class="string">"1"</span>)
    .setSource(json).<span class="built_in">get</span>();

IndexResponse response = client.prepareIndex(<span class="string">"tseg"</span>,<span class="string">"students"</span>,<span class="string">"1"</span>)
   .setSource(jsonBuilder()
   .startObject()
   .field(<span class="string">"first_name"</span>, <span class="string">"Shuang"</span>)
   .field(<span class="string">"first_name"</span>, <span class="string">"Peng"</span>)
   .field(<span class="string">"age"</span>, <span class="number">24</span>)
   .field(<span class="string">"about"</span>, <span class="string">"I love coding"</span>)
   .endObject())
   .<span class="built_in">get</span>();
</code></pre><p><strong>注意</strong>：Index API 只能用于创建 index，类似于关系型数据库里面的 create table，他不能对已有的数据库进行添加。追加操作可以用后面会提到的 Update 或者 Bulk 来完成。    </p>
<h3 id="Get_API_获取_Document">Get API 获取 Document</h3><pre><code>GetResponse response2 = client.prepareGet(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"1"</span>).<span class="literal">get</span>();
<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; res = response2.getSource();
<span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; entry: res.entrySet()){
     System.out.println(entry.getKey() + <span class="string">" : "</span> + entry.getValue());
     }
</code></pre><h3 id="Delete_API_删除_Index_或者_Document">Delete API 删除 Index 或者 Document</h3><pre><code><span class="comment">// 用来删除对应的 document </span>
DeleteResponse response3 = 
    <span class="keyword">client</span>.prepareDelete(<span class="string">"tesg"</span>,<span class="string">"students"</span>,<span class="string">"1"</span>).get();
<span class="comment">// 用来删除对应的 index</span>
DeleteIndexResponse response4 = 
    <span class="keyword">client</span>.admin().indices().prepareDelete(<span class="string">"facebook"</span>).execute().actionGet();
</code></pre><h3 id="Update_API_更新操作">Update API 更新操作</h3><p>更新操作也有两种方法。建议使用第一种，第二种太复杂了。。。看看就好。</p>
<p>第一种</p>
<pre><code>client.prepareUpdate(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"1"</span>)
    .setDoc(jsonBuilder<span class="literal">()</span>
    .startObject<span class="literal">()</span>.field(<span class="string">"age"</span>, <span class="number">32</span>)
    .endObject<span class="literal">()</span>)
    .get<span class="literal">()</span>;
</code></pre><p>第二种</p>
<pre><code>IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"1"</span>)
    .source(jsonBuilder()
    .startObject()
    .<span class="keyword">field</span>(<span class="string">"first_name"</span>, <span class="string">"Shuang"</span>)
    .<span class="keyword">field</span>(<span class="string">"last_name"</span>, <span class="string">"Peng"</span>)
    .<span class="keyword">field</span>(<span class="string">"age"</span>, <span class="number">32</span>)
    .<span class="keyword">field</span>(<span class="string">"about"</span>, <span class="string">"I loving coding"</span>)
    .endObject());

UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">"tseg"</span>,<span class="string">"students"</span>, <span class="string">"1"</span>)
    .doc(jsonBuilder()
    .startObject().<span class="keyword">field</span>(<span class="string">"age"</span>, <span class="number">32</span>)
    .endObject())
    .upsert(indexRequest);
 client.update(updateRequest).get();
</code></pre><p>不过这里提一下第二种方法，如果对应的 <strong>field</strong> 不存在的话，则更新操作自动变为插入操作，否则，就是正常的修改操作。</p>
<h3 id="Multi_Get_API_多查找">Multi Get API 多查找</h3><p><strong>MultiGetResponse</strong> API 可以一次返回多个要查找的值。下面介绍了两种方法，一种是返回一个 Map，我们可以按照不同的 field 取值；第二种方法是直接返回一个字符串（Json格式）。</p>
<pre><code>MultiGetResponse multiGetItemResponses = client.prepareMultiGet()
    .<span class="built_in">add</span>(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).<span class="built_in">get</span>();

<span class="keyword">for</span> (MultiGetItemResponse itemResponses : multiGetItemResponses) {
    GetResponse response5 = itemResponses.getResponse();
    <span class="keyword">if</span> (response5.isExists()) {

<span class="comment">// 第一种用法</span>
    Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; fields = response5.getSource();
    System.out.<span class="built_in">println</span>(fields.<span class="built_in">get</span>(<span class="string">"first_name"</span>));

<span class="comment">// 第二种用法</span>
    <span class="keyword">String</span> json2 = response5.getSourceAsString();
    System.out.<span class="built_in">println</span>(json2);
}
</code></pre><h3 id="Bulk_API_批量操作">Bulk API 批量操作</h3><p>Bulk API允许批量提交index和delete请求， 如下：</p>
<pre><code>BulkRequestBuilder bulkRequest = client.prepareBulk();
bulkRequest.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"1"</span>)
           .setSource(jsonBuilder()
           .startObject()
           .field(<span class="string">"first_name"</span>, <span class="string">"Allen"</span>)
           .field(<span class="string">"last_name"</span>, <span class="string">"Peng"</span>)
           .field(<span class="string">"age"</span>, <span class="string">"22"</span>)
           .endObject()))
           .<span class="built_in">get</span>();

bulkRequest.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"tseg"</span>, <span class="string">"students"</span>, <span class="string">"2"</span>))
            .setSource(jsonBuilder()
            .startObject()
            .field(<span class="string">"first_name"</span>, <span class="string">"Hou"</span>)
            .field(<span class="string">"last_name"</span>, <span class="string">"Xue"</span>)
            .field(<span class="string">"age"</span>, <span class="string">"30"</span>)
            .endObject()))
            .<span class="built_in">get</span>();

<span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; json2 = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();
List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();
list.<span class="built_in">add</span>(<span class="string">"music"</span>);
list.<span class="built_in">add</span>(<span class="string">"football"</span>);
json2.put(<span class="string">"first_name"</span>, <span class="string">"Peng"</span>);
json2.put(<span class="string">"last_name"</span>, <span class="string">"Peng"</span>);
json2.put(<span class="string">"interests"</span>, list);
BulkRequestBuilder bulkRequest2 = client.prepareBulk();

<span class="comment">// 两种执行方法，个人倾向于第一种</span>
bulkRequest2.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"facebook"</span>, <span class="string">"info"</span>, 
    <span class="string">"3"</span>).setSource(json2)).<span class="built_in">get</span>();
<span class="comment">// 第二种方法</span>
bulkRequest2.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"facebook"</span>, 
    <span class="string">"info"</span>,<span class="string">"1"</span>).setSource(json2)).execute().actionGet();
</code></pre><p>还可以这样做：</p>
<pre><code>BulkRequestBuilder bulkRequest = client.prepareBulk();
bulkRequest.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"index1"</span>, <span class="string">"type1"</span>, <span class="string">"id1"</span>)
    .setSource(<span class="keyword">source</span>);
bulkRequest.<span class="built_in">add</span>(client.prepareIndex(<span class="string">"index2"</span>, <span class="string">"type2"</span>, <span class="string">"id2"</span>)
    .setSource(<span class="keyword">source</span>);
BulkResponse bulkResponse = bulkRequest.<span class="keyword">execute</span>().actionGet();
</code></pre><h3 id="Bulk_Processor_API_可在批量操作完成之前和之后进行相应的操作">Bulk Processor API 可在批量操作完成之前和之后进行相应的操作</h3><pre><code>BulkProcessor bulkProcessor = BulkProcessor.builder(
        client,  
        <span class="keyword">new</span> BulkProcessor.Listener() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeBulk</span><span class="params">(<span class="keyword">long</span> executionId,
                                  BulkRequest request)</span> </span>{ ... } 

            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterBulk</span><span class="params">(<span class="keyword">long</span> executionId,
                                  BulkRequest request,
                                  BulkResponse response)</span> </span>{ ... } 

            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterBulk</span><span class="params">(<span class="keyword">long</span> executionId,
                                  BulkRequest request,
                                  Throwable failure)</span> </span>{ ... } 
        })
        .setBulkActions(<span class="number">10000</span>) 
        .setBulkSize(<span class="keyword">new</span> ByteSizeValue(<span class="number">1</span>, ByteSizeUnit.GB)) 
        .setFlushInterval(TimeValue.timeValueSeconds(<span class="number">5</span>)) 
        .setConcurrentRequests(<span class="number">1</span>) 
         .build();

bulkProcessor.add(<span class="keyword">new</span> IndexRequest(<span class="string">"index1"</span>, <span class="string">"type1"</span>, <span class="string">"id1"</span>).source(source1));  
bulkProcessor.add(<span class="keyword">new</span> DeleteRequest(<span class="string">"index2"</span>, <span class="string">"type2"</span>, <span class="string">"id2"</span>);        
</code></pre><ol>
<li>beforeBulk 会在批量提交之前执行，可以从 BulkRequest 中获取请求信息request.requests() 或者请求数量 request.numberOfActions()。 </li>
<li>第一个 afterBulk 会在批量成功后执行，可以跟 beforeBulk 配合计算批量所需时间。 </li>
<li>第二个 afterBulk 会在批量失败后执行。 </li>
<li>在例子中，当请求超过 10000 个（default=1000）或者总大小超过1GB（default=5MB）时，触发批量提交动作。</li>
</ol>
<h3 id="后记">后记</h3><p>项目代码已经共享至 <a href="https://github.com/pengshuang/LearnElastic/blob/master/src/main/java/Part1.java" target="_blank" rel="external">GitHub</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/22/一致性-Hash-学习/" itemprop="url">
                  一致性 Hash 学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-22T10:00:39+08:00" content="2016-11-22">
              2016-11-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/22/一致性-Hash-学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/22/一致性-Hash-学习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/22/一致性-Hash-学习/" class="leancloud_visitors" data-flag-title="一致性 Hash 学习">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一致性 Hash 算法为了解决因特网中的热点问题，它提出了在动态变化的 Cache 环境中，判定 Hash 算法好坏的四个定义：</p>
<ol>
<li><p><strong>平衡性</strong>：平衡性是指哈希的结果能够尽可能分不到所有的缓冲中去，这样可以使得所有的缓冲都得到利用。</p>
</li>
<li><p><strong>单调性</strong>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p>
</li>
<li><p><strong>分散性</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p>
</li>
<li><p><strong>负载</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
</li>
</ol>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的 <strong>hash(object)%N</strong> 算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。</p>
<h4 id="环形Hash空间">环形Hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</p>
<p><img src="/img/h1.png" alt=""></p>
<p><strong>把数据通过一定的hash算法处理后映射到环上</strong></p>
<p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p>
<pre><code><span class="function"><span class="title">Hash</span><span class="params">(object1)</span></span> = key1；
<span class="function"><span class="title">Hash</span><span class="params">(object2)</span></span> = key2；
<span class="function"><span class="title">Hash</span><span class="params">(object3)</span></span> = key3；
<span class="function"><span class="title">Hash</span><span class="params">(object4)</span></span> = key4；
</code></pre><p><img src="/img/h2.JPG" alt=""></p>
<p><strong>将机器通过hash算法映射到环上</strong></p>
<p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有 Cache A，Cache B，Cache C 三台机器，通过 Hash 算法得到对应的 KEY 值，映射到环中，其示意图如下：</p>
<pre><code>Hash<span class="list">(<span class="keyword">NODE1</span>)</span> = KEY1<span class="comment">;</span>
Hash<span class="list">(<span class="keyword">NODE2</span>)</span> = KEY2<span class="comment">;</span>
Hash<span class="list">(<span class="keyword">NODE3</span>)</span> = KEY3<span class="comment">;</span>
</code></pre><p><img src="/img/h3.JPG" alt=""></p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动 object1 存储到了Cache A 中，object3 存储到了 Cache B 中，object2、object4 存储到了 Cache C中。在这样的部署环境中，hash 环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p>
<p><strong>机器的删除与添加</strong></p>
<p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p>
<ol>
<li><p>节点（机器）的删除<br> 以上面的分布为例，如果 Cache B 出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到 Cache C 中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p>
<p> <img src="/img/h4.JPG" alt=""></p>
</li>
<li><p>节点（机器）的添加<br> 如果往集群中添加一个新的节点 Cache D，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</p>
<p> <img src="/img/h5.JPG" alt=""></p>
</li>
</ol>
<p>通过按顺时针迁移的规则，那么object2被迁移到了 Cache D 中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h4 id="参考资料">参考资料</h4><ul>
<li><p><a href="http://www.codeproject.com/Articles/56138/Consistent-hashing" target="_blank" rel="external">Consistent hashing</a></p>
</li>
<li><p><a href="http://blog.csdn.net/cywosp/article/details/23397179/#comments" target="_blank" rel="external">五分钟理解一致性哈希算法</a></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/18/IP协议相关技术-ICMP、DHCP-和-NAT/" itemprop="url">
                  IP协议相关技术: ICMP、DHCP 和 NAT
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-18T21:20:37+08:00" content="2016-11-18">
              2016-11-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/18/IP协议相关技术-ICMP、DHCP-和-NAT/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/18/IP协议相关技术-ICMP、DHCP-和-NAT/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/18/IP协议相关技术-ICMP、DHCP-和-NAT/" class="leancloud_visitors" data-flag-title="IP协议相关技术: ICMP、DHCP 和 NAT">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="辅助_IP_的_ICMP">辅助 IP 的 ICMP</h3><p>架构 IP 网络时需要特别注意：1. 确认网络是否正常工作；2. 遇到异常时进行问题诊断，而这一切需要 ICMP 来提供。</p>
<p>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在，这时，路由器 2 就会向主机 A 发送一个 ICMP 包，说明发往主机 B 的包未能成功。</p>
<p>ICMP 的消息大致可以分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p>
<h3 id="主要的_ICMP_消息">主要的 ICMP 消息</h3><h4 id="ICMP_目标不可达消息（类型3）">ICMP 目标不可达消息（类型3）</h4><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>在实际通信中经常遇到的错误代码是 1，表示主机不可达，它是指路由表中没有该主机的信息，或该主机没有连接到网络的意思。其他的错误号都可以通过查阅得知具体的错误信息，这里不再赘述。</p>
<h4 id="ICMP_重定向消息（类型5）">ICMP 重定向消息（类型5）</h4><p>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个 ICMP 重定向（ICMP Redirect Message）的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息给发送端主机一个更合适的发送路由。</p>
<h4 id="ICMP_超时消息（类型11）">ICMP 超时消息（类型11）</h4><p>IP 包中有一个字段叫做 TTL (生存周期），它的值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。此时，IP 路由器将会发送一个 ICMP 超时的消息给发送端主机，并通知该包已被丢弃。</p>
<p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发送循环状况时，避免 IP 包无休止地在网络上被转发。此外，有时可以用 TTL 控制包的到达范围，例如设置一个较小的 TTL 值。</p>
<p>有一个重复利用 ICMP 超时消息的应用叫 traceroute。他可以显示由执行程序的主机到达特定主机之前经历多少路由器。它的原理就是利用 IP 包的生存期限从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。这样可以将所有路由器的 IP 地址逐一呈现。这个过去常用于进行问题诊断。</p>
<h4 id="ICMP_回送消息（类型0、8）">ICMP 回送消息（类型0、8）</h4><p>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。可以向对端主机发送回送请求的消息，也可以接收对端主机发回来的回送应答消息，网络上最常用的 ping 命令就是利用这个消息实现的。</p>
<h3 id="ICMPv6">ICMPv6</h3><h4 id="ICMPv6_的作用">ICMPv6 的作用</h4><p>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4.即在 IPv4 中，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</p>
<p>在 IPv6 中， 从 IP 地址定位 MAC 地址的协议从 ARP 转为 ICMP 的邻居探索消息。这种邻居探索消息融合了 IPv4 的 ARP、ICMP 重定向以及 ICMP 路由器选择消息等功能于一体，甚至还提供自动设置 IP 地址的功能。</p>
<p>ICMPv6 中将 ICMP 大致分为两类：一类是错误消息，另一类是信息消息。类型 0 ~ 127 属于错误消息，128~255 属于信息消息。</p>
<h4 id="邻居探索">邻居探索</h4><p>ICMPv6 中从类型 133 至类型 137 的消息叫做邻居探索消息。这种邻居探索消息对于 IPv6 通信起着举足轻重的作用。邻居请求消息用于查询 IPv6 的地址与 MAC 地址的对应关系，并由邻居宣告消息得知 MAC 地址。邻居请求消息利用 IPv6 的多播地址实现传输。</p>
<h3 id="DHCP">DHCP</h3><p>如果为每一台主机设置 IP 地址会非常繁琐。所以，为了实现自动设置 IP 地址、同一管理 IP 地址分配，就产生了 DHCP 协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。</p>
<h4 id="DHCP_的工作机制">DHCP 的工作机制</h4><p>使用 DHCP 之前，首先要架设一台 DHCP 服务器。然后将 DHCP 所要分配的 IP 地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及 DNS 服务器的地址等设置到服务器上。</p>
<p>为了检查所要分配的 IP 地址以及已经分配了的 IP 地址是否可用，DHCP 服务器或 DHCP 客户端必须具备以下功能：</p>
<ul>
<li><p>DHCP 服务器</p>
<p>  在分配 IP 地址前发送 ICMP 回送请求包，确认没有返回应答。</p>
</li>
<li><p>DHCP 客户端</p>
<p>  针对从 DHCP 那里获得的 IP 地址发送 ARP 请求包，确认没有返回应答。</p>
</li>
</ul>
<h3 id="NAT">NAT</h3><p>NAT 用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。除转换 IP 地址外，还出现了可以转换 TCP、UDP 的端口号的 NAPT 技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/17/IP协议相关技术-DNS-和-ARP/" itemprop="url">
                  IP协议相关技术: DNS 和 ARP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-17T20:32:26+08:00" content="2016-11-17">
              2016-11-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/17/IP协议相关技术-DNS-和-ARP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/17/IP协议相关技术-DNS-和-ARP/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/17/IP协议相关技术-DNS-和-ARP/" class="leancloud_visitors" data-flag-title="IP协议相关技术: DNS 和 ARP">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="DNS">DNS</h3><p>我们平常在访问某个网站时不使用 IP 地址，而是用一串由字母和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样的原因主要是因为有 DNS 功能的支持。DNS 可以将它们自动转换为具体的 IP 地址。</p>
<h4 id="IP_地址不便记忆">IP 地址不便记忆</h4><p>TCP/IP 网络中要求每一个互连的计算机都具有其唯一的 IP 地址，并基于这个 IP 地址进行通信，但是 IP 地址并不容易记忆。</p>
<p>为此， TCP/IP 世界中从一开始就已经有了一个叫主机识别码的东西。它为每台计算机赋以唯一的主机名，在进行网络通信时可以直接使用主机名称而无需输入长串的 IP 地址。为了实现这种功能，主机往往会利用一个叫做 hosts 的数据库文件。</p>
<h4 id="DNS_产生">DNS 产生</h4><p>DNS 系统可以有效管理主机名和 IP 地址之间对应关系。这个系统中主机的管理机构可以对数据进行变更和设定，即它可以维护一个用来表示组织内部主机名和 IP 地址之间对应关系的数据库。</p>
<p>在应用中，当用户输入主机名（域名）时，DNS 会自动检索那个注册了主机名和 IP 地址的数据库，并迅速定位对应的 IP 地址。而且，如果主机名和 IP 地址需要进行变更时，也只需要在组织机构内部进行处理即可，而没必要再向其他机构进行申请或报告。</p>
<h3 id="ARP">ARP</h3><p>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</p>
<h4 id="ARP_概要">ARP 概要</h4><p>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。如果目标主机不在同一个链路上时，可以通过 ARP 查找下一跳路由器的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
<p>假定 主机 A 向同一链路上的主机 B 发送 IP 包，主机 A 的 IP 地址为 172.20.1.1，主机 B 的 IP 地址为 172.20.1.2，它们互不知道对方的 MAC 地址。</p>
<p>主机 A 为了获得主机 B 的 MAC 地址，起初要通过广播发送一个 ARP 请求包。这个包中包含了想要了解其 MAC 地址的主机 IP 地址。也就是说，ARP 请求包中已经包含了主机 B 的 IP 地址 172.20.1.2。由于广播的包可以被同一个链路上所有的主机或路由器接收，因此 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个节点就将自己的 MAC 地址塞入 ARP 响应包返回给主机 A。</p>
<p>从一个 IP 地址发送 ARP 请求包以了解其 MAC 地址，目标地址将自己的 MAC 地址填入其中的 ARP 响应包返回到 IP 地址。由此，可以通过 ARP 从 IP 地址获得 MAC 地址，实现链路内的 IP 通信。</p>
<p>根据 ARP 可以动态地进地址解析，因此，在 TCP/IP 的网络构造和网络通信中无需事先知道 MAC 地址究竟是什么，只要有 IP 地址即可。如果每发送一个 IP 数据报都要进行一次 ARP 请求以此确定 MAC 地址，那将会造成不必要的网络流量，因此，通常是把获取到的 MAC 地址缓存一段时间。即把第一次通过 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系记忆到一个 ARP 缓存表中，下一次再向这个 IP 地址发送数据报时不需要再重新发送 ARP 请求，而是直接使用这个缓存表当中的 MAC 地址进行数据报的发送。每执行一次 ARP，其对应的缓存内容都会被清除。不过在清除之前都可以不需要执行 ARP 就可以获取想要的 MAC 地址。这样，在一定程度上防止了 ARP 包在网络上被大量广播的可能性。</p>
<h4 id="IP_地址和_MAC_地址都需要吗？">IP 地址和 MAC 地址都需要吗？</h4><p>可能会有这么一个问题，数据链路上只要知道接收端的 MAC 地址就可可以发送数据了，还需要知道它的 IP 地址吗？</p>
<p>答案是肯定的，如果我们考虑发送给其他数据链路中某一台主机时的情况。如果主机 A 和 主机 B 不在同一个链路，主机 A 想要发送 IP 数据报给主机 B 时必须得经过路由器 C。即使知道了主机 B 的 MAC 地址，由于路由器 C 会隔断两个网络，还是无法实现从主机 A 发送数据报给主机 B。此时，主机 A 必须得先将数据报发送给路由器 C 的 MAC 地址。</p>
<p>在以太网上发送 IP 包时，“下次要经由哪个路由器发送数据报” 这一信息非常重要。而这里的“下一个路由器”就是相应的 MAC 地址。</p>
<h4 id="RARP">RARP</h4><p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。我们平时可以通过个人电脑设置 IP 地址，也可以通过 DHCP 自动分配获取 IP 地址。然而，对于使用嵌入式设备，会遇到没有任何输入接口或无法通过 DHCP 动态获取 IP 地址的情况。在类似这种情况下，就可以使用 RARP。</p>
<h4 id="代理_ARP">代理 ARP</h4><p>通常 ARP 包会被路由隔离，但是采用代理 ARP（Proxy ARP）的路由器可以将 ARP 请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/HBase架构学习-数据查找和传输/" itemprop="url">
                  HBase架构学习: 数据查找和传输
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-14T15:06:44+08:00" content="2016-11-14">
              2016-11-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HBase/" itemprop="url" rel="index">
                    <span itemprop="name">HBase</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/14/HBase架构学习-数据查找和传输/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/HBase架构学习-数据查找和传输/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/14/HBase架构学习-数据查找和传输/" class="leancloud_visitors" data-flag-title="HBase架构学习: 数据查找和传输">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在介绍 HBase 架构之前，首先来介绍典型的 RDBMS 和其他非关系型数据库底层存储结构之间的不同。其中传统关系型存储引擎广泛采用了 B 树和 B + 树；而 BigTable 的底层架构则采用了 LSM 树（Log-Structured Merge Tree）。</p>
<h3 id="B_+_树">B + 树</h3><p>B + 树的一些特性使其能够通过主键对记录进行高效插入、查找以及删除。它表示为一个动态、多层并有上下界的索引。同时要注意维护每一段（也被称作页表）所包含的主键数目。分段 B + 树的效果远好于二叉树的数据划分，其大大减少了查询特定主键所需的 I/O 操作。</p>
<p>除此之外，B + 树能够提供高效的范围扫描功能，这得益于它的叶节点相互连接并且按主键有序，扫描时避免了耗时的遍历树操作。这也是 B + 树被关系型数据库用作索引的原因之一。</p>
<h3 id="LSM_树">LSM 树</h3><p>LSM 树与 B + 树不同，它按照另一种方式组织数据。输入数据首先被存储在日志文件，这些文件内的数据完全有序。当有日志文件被修改时，对应的更新会先保存在内存中来加速查询。</p>
<p>当系统经历过许多次数据修改，且内存空间被逐渐占满后，LSM 树会把有序的“键 - 记录”对写到磁盘中，同时创建一个新的数据存储文件。此时，因为最近的修改都被持久化了，内存中保存的最近更新就可以被丢弃了。</p>
<p>存储文件的组织与 B 树相似，不过其为磁盘顺序读取做了优化，所有节点都是满的并按页存储。修改数据文件的操作通过滚动合并完成，即，系统将现有的页与内存刷写数据混合在一起进行管理，直到数据块达到它的容量。</p>
<p>多次数据刷写之后会创建许多数据存储文件，后台线程就会自动将小文件聚合成大文件，这样磁盘查找就会被限制在少数几个数据存储文件中。磁盘上的树结构也可以拆分成独立的小单元，这样更新就可以被分散到多个数据存储文件中。所有的数据存储文件都按键排序，所以没有必要再存储文件中为新的键预留位置。</p>
<p>查询时先查找内存中的存储，然后再查找磁盘上的文件。这样在客户端看来数据存储文件的位置是透明的。</p>
<p>删除是一种特殊的更改，当删除标记被存储之后，查找会跳过这些删除过的键。当页被重写时，有删除标记的键会被丢弃。</p>
<p>此外，后台运维过程可以处理预先设定的删除请求。这些请求由 TTL 触发，例如当 TTL 设为 20 天后，合并进程会检查这些预设的时间戳，同时在重写数据块时丢弃过期的记录。</p>
<p>B 树 和 LSM 树最主要的区别在于它们的结构如何利用硬件，特别是磁盘。</p>
<p>比较 B + 树 和 LSM 树的意义在于理解它们的相对优势和不足。在没有太多的修改时，B + 树表现得很好，因为这些修改要求执行高代价的优化操作以保证查询能在有限时间内完成。在任意位置添加数据的规模越大、速度越快，这些页成为碎片的速度就越快。最后，用户写入的速度可能比优化后重写文件的处理速度更快。由于更新和删除以磁盘寻道的速率完成，这就强制用户就范于磁盘提供的较差的性能指标。</p>
<p>LSM 树以磁盘传输速率工作并能较好地扩展以处理大量的数据。它们使用日志文件和内存存储来将随机写转换成顺序写，因此也能保证稳定的数据插入速率。由于读和写独立，因此在这两种操作之间没有冲突。</p>
<p>由于存储数据的布局较优，查询一个键需要的磁盘寻道次数在一个可预测的范围内，并且读取与该键连续的任意数量的记录都不会引发任何额外的磁盘寻道。一般来说，基于 LSM 树的系统强调的是成本透明：假如有 5 个存储文件，一个访问需要最多 5 次磁盘寻道。反观关系型数据库，即使在存在索引的情况下，它也没有办法确定一次查询需要的寻道次数。</p>
<p>所以， HBase 和 BigTable 一样，都是基于 LSM 树的系统。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/12/HBase学习-计数器/" itemprop="url">
                  HBase学习: 计数器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-12T20:51:25+08:00" content="2016-11-12">
              2016-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HBase/" itemprop="url" rel="index">
                    <span itemprop="name">HBase</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/12/HBase学习-计数器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/12/HBase学习-计数器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/12/HBase学习-计数器/" class="leancloud_visitors" data-flag-title="HBase学习: 计数器">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="计数器简介">计数器简介</h3><p>许多收集统计信息的应用有点击流或在线广告意见，这些应用需要被收集到日志文件中用于后续的分析。用户可以使用计数器做实时统计，从而放弃延时较高的批量操作。</p>
<h3 id="单计数器">单计数器</h3><p>第一种增加操作只能操作一个计数器：用户需要自己设定列，方法由 HTable 提供，如下所示：</p>
<pre><code><span class="keyword">long</span> incrementColumnValue(<span class="keyword">byte</span>[] row, <span class="keyword">byte</span>[] family, <span class="keyword">byte</span>[] 
    qualifier, <span class="keyword">long</span> amount) <span class="keyword">throws</span> IOException
<span class="keyword">long</span> incrementColumnValue(<span class="keyword">byte</span>[] row, <span class="keyword">byte</span>[] family, <span class="keyword">byte</span>[] 
    qualifier, <span class="keyword">long</span> amount, <span class="keyword">boolean</span> writeToWAL) <span class="keyword">throws</span> IOException
</code></pre><p>这两种方法都需要提供列的坐标和增加值，除此之外这两种方法只在参数 writeToWAL 上有差别，这个参数的作用与 Put.setWriteToWAL() 方法一致。忽略该参数会直接使用默认值 True。下面举一个使用单计数器的列子。</p>
<pre><code>Configuration conf = HBaseConfiguration<span class="built_in">.</span>create();
HTable hTable = <span class="literal">new</span> HTable(conf, <span class="string">"temp2"</span>);
<span class="comment">// 计数器值加一</span>
long cnt1 = hTable<span class="built_in">.</span>incrementColumnValue(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"20160101"</span>),
        <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), <span class="number">1</span>);
long cnt2 = hTable<span class="built_in">.</span>incrementColumnValue(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"20160101"</span>),
        <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), <span class="number">1</span>);
<span class="comment">// 得到计数器的当前值</span>
long current = hTable<span class="built_in">.</span>incrementColumnValue(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"20160101"</span>),
        <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), <span class="number">0</span>);

long cnt3 = hTable<span class="built_in">.</span>incrementColumnValue(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"20160101"</span>),
        <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), -<span class="number">1</span>);
</code></pre><p>对应的输出结果为：</p>
<pre><code>cnt1: <span class="number">1</span>, cnt2: <span class="number">2</span>, current: <span class="number">2</span>, cnt: <span class="number">3</span>
</code></pre><h3 id="多计数器">多计数器</h3><p>另一个计数器值的途径是使用 HTable() 的方法 increment()。工作模式与 CRUD 操作类似。使用以下方法完成该功能：</p>
<pre><code>Result <span class="function"><span class="title">increment</span><span class="params">(Increment increment)</span></span> throws IOException 
</code></pre><p>用户需要创建一个 Increment 实例，同时需要填充一些相应的的细节到该实例中，比如：</p>
<pre><code><span class="function"><span class="title">Increment</span><span class="params">()</span></span>
<span class="function"><span class="title">Increment</span><span class="params">(byte[] row)</span></span>
<span class="function"><span class="title">Increment</span><span class="params">(byte[] row, RowLock rowLock)</span></span>
</code></pre><p>用户构造 Increment 实例时需要传入行键，此行应当包含此实例需要通过 increment() 方法修改的所有计数器。</p>
<p>可选参数 rowLock 设置了用户自定义锁实例，这样可以使本次操作完全在用户的控制下完成，例如，当用户需要多次修改同一行时，可以保证其间此行不被其他写程序修改。</p>
<p>一旦用户使用行键创建了一个 Increment 实例，就需要向其中加入实际的计数器，也就是说，用户需要增加列，使用方法如下：</p>
<pre><code>Increment addColumn(<span class="keyword">byte</span>[] family, <span class="keyword">byte</span>[] qualifier, <span class="keyword">long</span> amount)
</code></pre><p>Increment 类的特别功能是可以增加一个时间范围：</p>
<pre><code>Increment setTimeRange(<span class="keyword">long</span> minStamp, <span class="keyword">long</span> maxStamp) <span class="keyword">throws</span> IOException
</code></pre><p>用户限制时间的范围，可以用来屏蔽比较老的计数器，使它们看上去不存在，一次增加操作会认为较老的计数器不存在，并把它们重置为 1。</p>
<p>下面这个例子表示增加了一行中多个计数器的计数。</p>
<pre><code> Increment increment1 = <span class="literal">new</span> Increment(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"20160101"</span>));
increment1<span class="built_in">.</span>addColumn(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"clicks"</span>), <span class="number">1</span>);
increment1<span class="built_in">.</span>addColumn(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"daily"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), <span class="number">1</span>);
increment1<span class="built_in">.</span>addColumn(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"weekly"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"click"</span>), <span class="number">10</span>);
increment1<span class="built_in">.</span>addColumn(<span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"weekly"</span>), <span class="built_in">Bytes</span><span class="built_in">.</span>toBytes(<span class="string">"hits"</span>), <span class="number">10</span>);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/分布式系统学习-ZooKeeper与Paxos/" itemprop="url">
                  分布式系统学习: ZooKeeper与Paxos
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T21:06:27+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/09/分布式系统学习-ZooKeeper与Paxos/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/09/分布式系统学习-ZooKeeper与Paxos/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/09/分布式系统学习-ZooKeeper与Paxos/" class="leancloud_visitors" data-flag-title="分布式系统学习: ZooKeeper与Paxos">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ZooKeeper_的设计目标">ZooKeeper 的设计目标</h3><p>ZooKeeper致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。高性能使得 ZooKeeper 能够应用于那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于 ZooKeeper 实现一些复杂的同步原语。下面介绍一下 ZooKeeper 的四个设计目标。</p>
<h4 id="目标一：简单的数据模型">目标一：简单的数据模型</h4><p>ZooKeeper 使得分布式程序能够通过一个共享的、树型结构的名字空间来进行相互协调。这里的树型结构的名字空间，是指 ZooKeeper 服务器内的一个数据模型，其由一系列被称为 ZNode 的数据节点组成，总的来说，其数据模型类似于一个文件系统，而 ZNode 之间的层级关系，就像文件系统的目录结构一样。不过，ZooKeeper 将全量数据存储在内存中，以此来实现提高服务器吞吐、减少延迟的目的。</p>
<h4 id="目标二：可以构建集群">目标二：可以构建集群</h4><p>一个 ZooKeeper 集群通常由一组机器组成，一般 3 ~ 5 台机器就可以组成一个可用的 ZooKeeper 集群了。</p>
<p>组成 ZooKeeper 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持通信。只要集群中有超过半数的机器能够正常工作，那么整个集群就能够正常对外服务。</p>
<p>ZooKeeper 的客户端程序会选择和集群中任意一台机器共同创建一个 TCP 连接，而一旦客户端和某台 ZooKeeper 服务器之间的连接断开之后，客户端会自动连接到集群中的其他机器。</p>
<h4 id="目标三：顺序访问">目标三：顺序访问</h4><p>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 的这个特性来实现更高层次的同步原语。</p>
<h4 id="目标四：高性能">目标四：高性能</h4><p>由于 ZooKeeper 将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p>
<h3 id="ZooKeeper_基本概念">ZooKeeper 基本概念</h3><h4 id="集群角色">集群角色</h4><p>通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式是 Master/Slave 模式。在这种模式下，我们把能够处理所有写操作的机器称为 Master 机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器称为 Slave 机器。</p>
<p>而在 ZooKeeper 中，没有 Master/Slave，取而代之的是Leader、Follower 和 Observer 三种角色。ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为“Leader”的机器。Leader 服务器为客户端提供读和写服务。而 Follower 和 Observer 都能够提供读服务，它们唯一的区别在于，Observer 机器不参与 Leader 的选举，也不参与写操作的“过半写成功”策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p>
<h4 id="会话">会话</h4><p>Session 是指客户端会话，在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。ZooKeeper 对外的端口是 2181，客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端的会话周期也开始了，通过这个连接，客户端可以通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout </p>
<h4 id="数据节点(Znode)">数据节点(Znode)</h4><p>在 ZooKeeper 中， 节点分为两类，第一类同样是指构成集群的集群，称为机器节点；第二类则是指数据模型中的数据单元，我们称为数据节点—Znode。ZooKeeper 将所有数据存储在内存中，数据模型是一棵树，由斜杠进行分割的路径就是一个 ZNode，例如 /foo/path1。每个 Znode 上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>
<p>在 ZooKeeper 中，Znode 节点可以分为持久节点和临时节点两类。持久节点一旦被创建了，除非主动移除，否则一直保存在 ZooKeeper 上；临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p>
<h4 id="Watcher">Watcher</h4><p>Watcher(事件监听器)，是 ZooKeeper 中的一个重要特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<h4 id="ACL">ACL</h4><p>ZooKeeper 采用 ACL 策略来进行权限控制，类似于 UNIX 文件系统的权限控制。ZooKeeper 定义了如下 5 种权限。</p>
<ul>
<li>CREATE</li>
<li>READ</li>
<li>WRITE</li>
<li>DELETE</li>
<li>ADMIN</li>
</ul>
<h3 id="ZooKeeper_的_ZAB_协议">ZooKeeper 的 ZAB 协议</h3><p>事实上，ZooKeeper 并没有完全采用 Paxos 算法，而是使用了一种称为 ZooKeeper Atomic Broadcast（ZAB）的协议作为其数据一致性的核心算法。</p>
<p>ZAB 协议是一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要通过 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。ZAB 协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此可以很好的处理大量客户端的并发请求。另一方面，考虑到在分布式环境中，顺序执行的一些状态变更前后会存在一定的依赖关系，因此 ZAB 协议必须保证一个全局的变更序列被顺序应用。最后考虑到主进程可能会存在崩溃的可能，所以，ZAB 协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。</p>
<p>ZAB 的核心是定义了对于那些会改变 ZooKeeper 服务器数据状态的事务请求的处理方式：</p>
<pre><code>所以的事务请求必须由一个全局的唯一的服务器来协调处理，它被称为 <span class="built_in">Leader</span>，其他的被
称为 Follower。<span class="built_in">Leader</span> 负责将一个客户端事务请求转换成一个事务 Proposal (提
议)，并将该 Proposal 分发给集群中所有的 Follower。之后 <span class="built_in">Leader</span> 服务器需要等
待所有 Follower 服务器反馈，一旦得到超过半数的 Follower 进行正确的反馈之后，
那么 <span class="built_in">Leader</span> 再次向所有的 Follower 发送 Commit 消息，要求其将前一个 
Proposal 进行提交。
</code></pre><p>ZAB 协议包括两种基本的模式，分别是崩溃恢复和消息广播。当整个服务框架在启动的过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。</p>
<p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。ZooKeeper 的设计只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。</p>
<p>当 Leader 服务器出现崩溃退出或机器重启，亦或集群中已经不存在过半的服务器与该 Leader 服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个 ZAB 流程就会从消息广播模式进入到崩溃恢复模式。</p>
<p>一个机器要称为新的 Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此，在 ZAB 协议运行过程中，前后会出现多个 Leader，并且每个进程也有可能或多次成为 Leader，并且每个进程也有可能会多次成为 Leader。进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的 Leader 并再次进入消息广播模式。</p>
<p>接下来重点介绍 ZAB 协议中的消息广播和崩溃恢复过程。</p>
<h3 id="消息广播">消息广播</h3><p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个二阶段提交过程。针对客户端的事务请求，Leader 服务器会为其生成对应的事务 Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。不过在 ZAB 协议的二阶段提交过程中，所有的 Follower 服务器要么正常反馈 Leader 提出的事务 Proposal，要么就抛弃 Leader 服务器。同时，ZAB 协议将二阶段提交中的中断逻辑移除意味着可以在过半 Follower 服务器已经反馈 Ack 之后就开始提交事务 Proposal 了，而不需要等待集群中所有的 Follower 服务器都反馈响应。整个消息广播协议使基于具有 FIFO 特性的 TCP 协议来进行网络通信的，因此能够很容易地保证消息广播过程中的消息接收与发送的顺序。</p>
<p>在整个消息广播过程中，Leader 服务器会为每个事务请求生成对应的 Proposal 来进行广播，并且在广播事务 Proposal 之前，Leader 服务器会首先为这个事务 Proposal 分配一个全局单调递增的唯一 ID，我们称之为事务 ID(即 ZXID)。由于 ZAB 协议需要保证每一个消息严格的因果关系，因此必须将每一个事务 Proposal 按照其 ZXID 的先后顺序来进行排序与处理。</p>
<p>具体的，在消息广播过程中，Leader 服务器会为每一个 Follower 服务器都各自分配一个单独的队列，然后将需要广播的事务 Proposal 依次放入这些队列中去，并且根据 FIFO 策略进行消息发送。每一个 Follower 服务器在接收到这个事务 Proposal 之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给 Leader 服务器一个 Ack 响应。当 Leader 服务器接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 服务器以通知其进行事务提交，同时 Leader 自身也会完成对事务的提交，而每一个 Follower 服务器在接收到 Commit 消息后，也会完成对事务的提交。</p>
<h3 id="崩溃恢复">崩溃恢复</h3><p>ZAB 协议的这个基于原子广播协议的消息传播过程，在正常情况下运行非常良好，但是一旦 Leader 服务器出现崩溃，或者说由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。在 ZAB 协议中，为了保证程序的正常运行，整个恢复过程结束后需要选举出一个新的 Leader 服务器。因此，ZAB 协议需要一个高效且可靠的 Leader 选举算法，从而确保能够快速地选举新的 Leader。同时，Leader 选举算法不仅需要让 Leader 自己知道其自身已经被选举为 Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的 Leader 服务器。</p>
<h3 id="数据同步">数据同步</h3><p>完成 Leader 选举之后，在正式开始工作（即接收客户端的事务请求，然后提出新的提案）之前，Leader 服务器会首先确认事务日志中的所有 Proposal 是否已经被集群中过半的机器提交了，即是否完成数据同步。ZAB 协议的数据同步过程如下：</p>
<p>所有正常运行的服务器，要么成为 Leader，要么成为 Follower 并和 Leader 保持同步。Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务 Proposal，并且能够正确地将所有已经提交了的事务 Proposal 应用到内存数据库中去。具体的，Leader 服务器会为每一个 Follower 服务器都准备一个队列，并将那些没有被各 Follower 服务器同步的事务以 Proposal 消息的形式逐个发送给 Follower 服务器，并在每一个 Proposal 消息后面紧接着再发送一个 Commit 消息，以表示该事务已经被提交。等到 Follower 服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应用到本地数据库中，Leader 服务器就会将该 Follower 服务器加入到真正的可用 Follower 列表中，并开始之后的其他流程。</p>
<h3 id="ZAB_与_Paxos_算法的联系与区别">ZAB 与 Paxos 算法的联系与区别</h3><p>ZAB 协议并不是 Paxos 算法的一个典型实现，但两者之间也存在很多联系：</p>
<ul>
<li>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行。</li>
<li>Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交。</li>
<li>在 ZAB 协议中，每个 Proposal 中都包含了一个 epoch 值，用来代表当前的 Leader 周期，在 Paxos 算法中，同样存在这样的一个标识，知识名字变成了 Ballot。</li>
</ul>
<p>ZAB 协议和 Paxos 算法的本质区别在于，两者的设计目标不太一样。ZAB 协议主要用于构建一个高可用的分布式数据主备系统，而 Paxos 算法则是用于构建一个分布式的一致性状态机系统。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/08/HBase学习-专用过滤器/" itemprop="url">
                  HBase学习: 专用过滤器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-08T17:25:26+08:00" content="2016-11-08">
              2016-11-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HBase/" itemprop="url" rel="index">
                    <span itemprop="name">HBase</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/08/HBase学习-专用过滤器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/08/HBase学习-专用过滤器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/08/HBase学习-专用过滤器/" class="leancloud_visitors" data-flag-title="HBase学习: 专用过滤器">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HBase 提供的第二类过滤器直接继承自 FilterBase，同时用于更特定的场景。其中一些过滤器只能做行筛选，因此只适用于扫描操作。</p>
<h3 id="单列值过滤器">单列值过滤器</h3><p>当用户用一列的值来决定是否一行数据被过滤时，可以考虑使用单列值过滤器。首先设定待检查的列，然后设置待检查的列的对应值。具体构造函数如下：</p>
<pre><code><span class="function">SingleColumnValueFilter</span>(byte<span class="attr_selector">[]</span> family, byte<span class="attr_selector">[]</span> qualifier,
    CompareOp compareOp, byte<span class="attr_selector">[]</span> value)
<span class="function">SingleColumnValueFilter</span>(byte<span class="attr_selector">[]</span> family, byte<span class="attr_selector">[]</span> qualifier,
    CompareOp compareOp, ByteArrayComparable comparator)
</code></pre><p>第一个构造函数比较简单，因为它只在内部创建了一个 BinaryComparator 实例。第二个构造函数中所需的参数与用户一直在使用的基于 CompareFilter 的类相同，尽管 SingleColumnValueFilter 并不是直接继承自 CompareFilter， 但还是使用了相同的参数类型。</p>
<p>同时，过滤器还提供了一些辅助方法帮助用户微调过滤行为:</p>
<pre><code>boolean <span class="function"><span class="title">getFilterIfMissing</span><span class="params">()</span></span>
void <span class="function"><span class="title">setFilterIfMissing</span><span class="params">(boolean filterIfMissing)</span></span>
boolean <span class="function"><span class="title">getLatestVersionOnly</span><span class="params">()</span></span>
void <span class="function"><span class="title">setLatestVersionOnly</span><span class="params">(boolean latestVersionOnly)</span></span>
</code></pre><p>前者决定了当参考列不存在时如何处理这一行。默认的这一行是被包含在结果中的。用户可以用 <strong>setFilterIfMissing(true)</strong> 来过滤这些行。即，这样设置之后所有不包含参考列的行都可以被过滤掉。</p>
<p>下面一个例子展示了如何使用过滤器返回包含特定列中特定值的行。</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);

<span class="type">SingleColumnValueFilter</span> filter = new <span class="type">SingleColumnValueFilter</span>(
        <span class="type">Bytes</span>.toBytes(<span class="string">"colfam1"</span>),
        <span class="type">Bytes</span>.toBytes(<span class="string">"col-5"</span>),
        <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">NOT_EQUAL</span>,
        new <span class="type">SubstringComparator</span>(<span class="string">"val-5"</span>));
filter.setFilterIfMissing(<span class="literal">true</span>);

<span class="type">Scan</span> scan = new <span class="type">Scan</span>();
scan.setFilter(filter);
<span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span>: scanner){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner.close();

<span class="type">Get</span> get = new <span class="type">Get</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-6"</span>));
get.setFilter(filter);
<span class="type">Result</span> <span class="literal">result</span> = hTable.get(get);
<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
</code></pre><h3 id="单列排除过滤器">单列排除过滤器</h3><p>单列排除过滤器继承自 SingleColumnValueFilter, 它的参考列不被包括在结果之中。</p>
<h3 id="前缀过滤器">前缀过滤器</h3><p>在构造当前过滤器的时候传入一个前缀，所有与前缀匹配的行都会被返回给客户端。构造函数如下：</p>
<pre><code>Public <span class="function"><span class="title">PrefixFilter</span><span class="params">(byte[] prefix)</span></span>
</code></pre><p>下面的例子展示了如何使用前缀过滤器。</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);

<span class="type">Filter</span> filter = new <span class="type">PrefixFilter</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-1"</span>));
<span class="type">Scan</span> scan = new <span class="type">Scan</span>();
scan.setFilter(filter);
<span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span> : scanner){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner.close();

<span class="type">Get</span> get = new <span class="type">Get</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-5"</span>));
get.setFilter(filter);
<span class="type">Result</span> <span class="literal">result</span> = hTable.get(get);
<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
</code></pre><h3 id="包含结束的过滤器">包含结束的过滤器</h3><p>扫描操作中的开始行被包含到结果中，但终止行被排除在外。在使用这个过滤器的时候，用户也可以将结束行包含在结果中。例如下面这个例子：</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);
<span class="type">Filter</span> filter = new <span class="type">InclusiveStopFilter</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-5"</span>));

<span class="type">Scan</span> scan = new <span class="type">Scan</span>();
scan.setStartRow(<span class="type">Bytes</span>.toBytes(<span class="string">"row-3"</span>));
scan.setFilter(filter);
<span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span>:scanner){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner.close();
</code></pre><h3 id="时间戳过滤器">时间戳过滤器</h3><p>当用户需要在扫描结果中对版本进行细粒度的控制时，这个过滤器可以满足需求。用户需要传入一个装载了时间戳的 List 实例。</p>
<pre><code><span class="function"><span class="title">TimestampFilter</span><span class="params">(List&lt;Long&gt; timestamps)</span></span>
</code></pre><p>下面这个例子展示了一个典型的时间戳过滤器，其中第一个扫描中使用了包括 3 个时间戳的过滤器，在第二个扫描中增加了一个时间范围限制。</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);

<span class="type">List</span>&lt;<span class="type">Long</span>&gt; ts = new <span class="type">ArrayList</span>&lt;<span class="type">Long</span>&gt;();
// 向列表中添加时间戳
ts.add(new <span class="type">Long</span>(<span class="number">5</span>));
ts.add(new <span class="type">Long</span>(<span class="number">10</span>));
ts.add(new <span class="type">Long</span>(<span class="number">15</span>));
<span class="type">Filter</span> filter = new <span class="type">TimestampsFilter</span>(ts);

<span class="type">Scan</span> scan1 = new <span class="type">Scan</span>();
// 向scan实例中添加过滤器
scan1.setFilter(filter);
<span class="type">ResultScanner</span> scanner1 = hTable.getScanner(scan1);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span>:scanner1){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner1.close();

<span class="type">Scan</span> scan2 = new <span class="type">Scan</span>();
scan2.setFilter(filter);
// 添加时间范围限制
scan2.setTimeRange(<span class="number">8</span>,<span class="number">12</span>);
<span class="type">ResultScanner</span> scanner2 = hTable.getScanner(scan2);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span>:scanner2){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner2.close();
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/07/HBase学习-比较过滤器/" itemprop="url">
                  HBase学习: 比较过滤器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-07T16:55:42+08:00" content="2016-11-07">
              2016-11-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HBase/" itemprop="url" rel="index">
                    <span itemprop="name">HBase</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/07/HBase学习-比较过滤器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/07/HBase学习-比较过滤器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/07/HBase学习-比较过滤器/" class="leancloud_visitors" data-flag-title="HBase学习: 比较过滤器">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HBase 提供的第一种过滤器实现就是<strong>比较过滤器</strong>。用户创建一个实例时需要一个比较运算符和一个比较器实例。每个比较过滤器的构造方法都有一个从 CompareFilter 继承来的签名方法。</p>
<pre><code>CompareFilter<span class="list">(<span class="keyword">CompareOp</span> valueCompareOp,
    WritableByteArrayCompareable valueComparator)</span>
</code></pre><p>用户需要提供比较运算符和比较类来让过滤器工作。</p>
<p>HBase 中过滤器本来的目的是为了筛掉无用的信息，被过滤掉的信息不会被传递到客户端，过滤器不能用来指定用户需要哪些信息，而是在读取数据的过程中不返回用户不想要的信息。</p>
<p>相反，所有基于 CompareFilter 的过滤处理过程与上述描述正好相反，它们返回匹配的值</p>
<h3 id="行过滤器">行过滤器</h3><p>行过滤器基于行键来过滤数据。下面一个例子展示了使用不同的过滤器来获得需要的行。</p>
<pre><code>Configuration conf = HBaseConfiguration.create();
HTable hTable = <span class="built_in">new</span> HTable(conf, <span class="string">"temp2"</span>);

Scan scan = <span class="built_in">new</span> Scan();
scan.addColumn(Bytes.toBytes(<span class="string">"colfam1"</span>), Bytes.toBytes(<span class="string">"col-0"</span>));
<span class="comment">// 指定比较运算符和比较器</span>
Filter filter1 = <span class="built_in">new</span> RowFilter(CompareFilter.CompareOp.LESS_OR_EQUAL,
        <span class="built_in">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"row-22"</span>)));
scan.setFilter(filter1);
ResultScanner scanner1 = hTable.getScanner(scan);
<span class="keyword">for</span>(Result res: scanner1){
    System.out.<span class="built_in">println</span>(res);
}
scanner1.<span class="built_in">close</span>();

<span class="comment">// 用正则表达式来匹配行键</span>
Filter filter2 = <span class="built_in">new</span> RowFilter(CompareFilter.CompareOp.EQUAL,
        <span class="built_in">new</span> RegexStringComparator(<span class="string">".*-.5"</span>));
scan.setFilter(filter2);
ResultScanner scanner2 = hTable.getScanner(scan);
<span class="keyword">for</span>(Result res: scanner2){
    System.out.<span class="built_in">println</span>(res);
}
scanner2.<span class="built_in">close</span>();

<span class="comment">// 子串匹配方法</span>
Filter filter3 = <span class="built_in">new</span> RowFilter(CompareFilter.CompareOp.EQUAL,
        <span class="built_in">new</span> SubstringComparator(<span class="string">"-5"</span>));
scan.setFilter(filter3);
ResultScanner scanner3 = hTable.getScanner(scan);
<span class="keyword">for</span>(Result res: scanner3){
    System.out.<span class="built_in">println</span>(res);
}
scanner3.<span class="built_in">close</span>();
</code></pre><h3 id="列族过滤器">列族过滤器</h3><p>和行过滤器类似，它通过比较列族而不是行键来返回结果。通过使用不同组合的运算符和比较器，用户可以在列族一级筛选所需的数据。下面一个例子展示了如何使用它。</p>
<pre><code>Configuration conf = HBaseConfiguration.create();
HTable hTable = <span class="keyword">new</span> HTable(conf, <span class="string">"temp2"</span>);
<span class="comment">// 创建一个过滤器, 指定比较运算符和比较器, 使用过滤器来返回特定的列族</span>
Filter filter1 = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.LESS,
        <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"colfam3"</span>)));
Scan scan = <span class="keyword">new</span> Scan();
scan.setFilter(filter1);
<span class="comment">// 使用扫描器扫描</span>
ResultScanner scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(Result res: scanner){
    System.<span class="keyword">out</span>.println(res);
}
scanner.close();

Get get1 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"row-5"</span>));
<span class="comment">// 使用和之前相同的过滤器获取同一行的数据</span>
get1.setFilter(filter1);
Result result1 = hTable.<span class="keyword">get</span>(get1);
System.<span class="keyword">out</span>.println(<span class="string">"Result of get(): "</span> + result1);

 <span class="comment">// 在一个列族上创建一个过滤器，同时获取另一行的数据</span>
Filter filter2 = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.EQUAL,
        <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"colfam3"</span>)));
Get get2 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"row-5"</span>));
get2.addFamily(Bytes.toBytes(<span class="string">"colfam1"</span>));
get2.setFilter(filter2);
<span class="comment">// 使用新的过滤器获取同一行数据，此时返回的结果为 None </span>
Result result2 = hTable.<span class="keyword">get</span>(get2);
System.<span class="keyword">out</span>.print(<span class="string">"Result of get(): "</span> + result2);
</code></pre><h4 id="列名过滤器">列名过滤器</h4><p>通过列名筛选特定的列。</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);

<span class="type">Filter</span> filter = new <span class="type">QualifierFilter</span>(<span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">LESS_OR_EQUAL</span>,
        new <span class="type">BinaryComparator</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"col-2"</span>)));
<span class="type">Scan</span> scan = new <span class="type">Scan</span>();
scan.setFilter(filter);
<span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span>: scanner){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner.close();

<span class="type">Get</span> get = new <span class="type">Get</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-5"</span>));
get.setFilter(filter);
<span class="type">Result</span> result2 = hTable.get(get);
<span class="type">System</span>.<span class="keyword">out</span>.print(result2);
</code></pre><h4 id="值过滤器">值过滤器</h4><p>值过滤器可以筛选某个特定值的单元格。</p>
<pre><code><span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
<span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);

<span class="type">Filter</span> filter = new <span class="type">ValueFilter</span>(<span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">EQUAL</span>,
        new <span class="type">SubstringComparator</span>(<span class="string">".4"</span>));
<span class="type">Scan</span> scan = new <span class="type">Scan</span>();
scan.setFilter(filter);
<span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
<span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span> : scanner){
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
}
scanner.close();
</code></pre><h3 id="参考列过滤器">参考列过滤器</h3><p>参考列过滤器允许用户指定一个参考列或者引用列，并使用参考列控制其他列的过滤。参考列过滤器使用参考列的时间戳，并在过滤时包括所有与引用时间戳相同的列。</p>
<p>下面是它们的构造方法：</p>
<pre><code><span class="label">DependentColumnFilter</span>(<span class="keyword">byte[] </span>family, <span class="keyword">byte[] </span>qualifier)
<span class="label">DependentColumnFilter</span>(<span class="keyword">byte[] </span>family, <span class="keyword">byte[] </span>qualifier,
    <span class="keyword">boolean </span>dropDependentColumn)
<span class="label">DependentColumnFilter</span>(<span class="keyword">byte[] </span>family, <span class="keyword">byte[] </span>qualifier,
    <span class="keyword">boolean </span>dropDependentColumn, CompareOp valueCompareOp,
    <span class="keyword">ByteArrayComparable </span>valueComparator)
</code></pre><p>由于参考过滤器也是继承自 CompareFilter，所以它也可以帮助用户筛选列，不过这个过滤器是基于这些列值进行筛选的。用户可以把他理解为一个 ValueFilter 和 一个时间戳过滤器的组合。用户可以传入比较运算符和基准值来启用 ValueFilter 的功能。</p>
<p>下面这个例子展示了参考过滤器的用法：</p>
<pre><code>public class <span class="type">Filter5</span> {
    private <span class="keyword">static</span> <span class="type">void</span> filter(boolean drop,
                               <span class="type">CompareFilter</span>.<span class="type">CompareOp</span> operator,
                               <span class="type">ByteArrayComparable</span> comparator)
    throws <span class="type">IOException</span> {
        <span class="type">Filter</span> filter;
        <span class="keyword">if</span>(comparator != null){
            filter = new <span class="type">DependentColumnFilter</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"colfam1"</span>),
                    <span class="type">Bytes</span>.toBytes(<span class="string">"col-5"</span>), drop, operator, comparator);
        } <span class="keyword">else</span> {
            filter = new <span class="type">DependentColumnFilter</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"colfam1"</span>),
                    <span class="type">Bytes</span>.toBytes(<span class="string">"col-5"</span>), drop);
        }

    <span class="type">Configuration</span> conf = <span class="type">HBaseConfiguration</span>.create();
    <span class="type">HTable</span> hTable = new <span class="type">HTable</span>(conf, <span class="string">"temp2"</span>);
    <span class="type">Scan</span> scan = new <span class="type">Scan</span>();
    scan.setFilter(filter);
    <span class="type">ResultScanner</span> scanner = hTable.getScanner(scan);
    <span class="keyword">for</span>(<span class="type">Result</span> <span class="literal">result</span> : scanner){
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);
    }
    scanner.close();

    <span class="type">Get</span> get = new <span class="type">Get</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"row-5"</span>));
    get.setFilter(filter);
    <span class="type">Result</span> <span class="literal">result</span> = hTable.get(get);
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);

}
public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">IOException</span>
{
    filter(<span class="literal">true</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">NO_OP</span>, null);
    filter(<span class="literal">false</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">NO_OP</span>, null);
    filter(<span class="literal">true</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">EQUAL</span>,
            new <span class="type">BinaryPrefixComparator</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"val-5"</span>)));
    filter(<span class="literal">false</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">EQUAL</span>,
            new <span class="type">BinaryPrefixComparator</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"val-5"</span>)));
    filter(<span class="literal">true</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">EQUAL</span>,
            new <span class="type">RegexStringComparator</span>(<span class="string">".*\\.5"</span>));
    filter(<span class="literal">false</span>, <span class="type">CompareFilter</span>.<span class="type">CompareOp</span>.<span class="type">EQUAL</span>,
            new <span class="type">RegexStringComparator</span>(<span class="string">".*\\.5"</span>));
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/29/HBase-学习-扫描/" itemprop="url">
                  HBase 学习: 扫描
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-29T10:30:50+08:00" content="2016-10-29">
              2016-10-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/29/HBase-学习-扫描/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/29/HBase-学习-扫描/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/29/HBase-学习-扫描/" class="leancloud_visitors" data-flag-title="HBase 学习: 扫描">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本概念">基本概念</h3><p>扫描技术 (scan) 类似于数据库系统中的游标，并利用到了 HBase 提供的底层顺序存储的数据结构。</p>
<p>Scan 类拥有以下构造器：</p>
<pre><code><span class="function"><span class="title">Scan</span><span class="params">()</span></span>
<span class="function"><span class="title">Scan</span><span class="params">(byte[] startRow, Filter filter)</span></span>
<span class="function"><span class="title">Scan</span><span class="params">(byte[] startRow)</span></span>
<span class="function"><span class="title">Scan</span><span class="params">(byte[] startRow, byte[] stopRow)</span></span>
</code></pre><p>我们可以选择性地提供 startRow 参数，来定义扫描读取 HBase 表的起始行键，即行键不是必须指定的。同时可选 stopRow 来限定读取到何时停止。</p>
<p>创建 Scan 实例之后，用户可能还要给它增加更多限制条件。可以使用多种方法限制所要读取的数据：</p>
<pre><code>Scan <span class="function"><span class="title">addFamily</span><span class="params">(byte[] family)</span></span>
Scan <span class="function"><span class="title">addColumn</span><span class="params">(byte[] family, byte[] qualifier)</span></span>
</code></pre><p>一旦设置好了 Scan 实例，就可以调用 Htable 的 getScanner() 方法，获得用于检索数据的 ResultScanner 实例。</p>
<p>扫描操作不会通过一次 RPC 请求返回所有匹配的行，而是以行为单位进行返回，很明显，行的数目很大，可能有上千条甚至更多，同时在一次请求中发送大量数据，会占用大量的系统资源并消耗很长时间。</p>
<p>ResultScanner 把扫描操作转换为类似的 get 操作，它将每一行数据封装成一个 Result 实例，并将所有的 Result 实例放入一个迭代器中，ResultScanner 的一些方法如下：</p>
<pre><code>Result <span class="function"><span class="title">next</span><span class="params">()</span></span> throws IOException
Result <span class="function"><span class="title">next</span><span class="params">(int nbRows)</span></span> throws IOException
void <span class="function"><span class="title">close</span><span class="params">()</span></span>
</code></pre><p>有 2 种类型的 next() 调用供用户选择。调用 close() 方法会释放所有由扫描控制的资源。</p>
<p>next() 调用返回一个单独的 Result 实例，这个实例代表了下一个可用的行。此外，用户可以使用 next(int nbRows) 一次获取多行数据，它返回一个数组，数组中包含的 Result 实例最多可达 nbRows 个，每个实例代表唯一的一行。下面展示了一个关于扫描的简单例子。</p>
<pre><code>Configuration conf = HBaseConfiguration.create();
HTable <span class="built_in">table</span> = new HTable(conf, <span class="string">"test"</span>);

Scan scan1 = new Scan();
ResultScanner scanner1 = <span class="built_in">table</span>.getScanner(scan1);
<span class="keyword">for</span> (Result res: scanner1) {
    System.<span class="keyword">out</span>.println(res);
}
scanner1.close();

Scan scan2 = new Scan();
scan2.addFamily(Bytes.<span class="keyword">to</span>Bytes(<span class="string">"colfam1"</span>));
ResultScanner scanner2 = <span class="built_in">table</span>.getScanner(scan2);
<span class="keyword">for</span> (Result res: scanner2) {
    System.<span class="keyword">out</span>.println(res);
}
scanner2.close();

Scan scan3 = new Scan();
// 使用 builder 模式将详细限制条件添加到 Scan 中
scan3.addColumn(Bytes.<span class="keyword">to</span>Bytes(<span class="string">"colfam1"</span>), Bytes.<span class="keyword">to</span>Bytes(<span class="string">"col-5"</span>))
        .addColumn(Bytes.<span class="keyword">to</span>Bytes(<span class="string">"colfam2"</span>), Bytes.<span class="keyword">to</span>Bytes(<span class="string">"col-33"</span>))
        .<span class="built_in">set</span>StartRow(Bytes.<span class="keyword">to</span>Bytes(<span class="string">"row-10"</span>)).<span class="built_in">set</span>StopRow(Bytes.<span class="keyword">to</span>Bytes(<span class="string">"row-20"</span>));
ResultScanner scanner3 = <span class="built_in">table</span>.getScanner(scan3);
<span class="keyword">for</span>(Result res: scanner3) {
    System.<span class="keyword">out</span>.println(res);
}
scanner3.close();
</code></pre><p><strong>注意</strong>：要确保尽早释放扫描器实例，一个打开的扫描器会占用不少服务端资源，累积多了会占用大量的堆空间。当使用完 ResultScanner 之后应调用它的 close() 方法，同时应当把 close() 方法放到 try/finally 块中，以保证其在迭代获取数据过程中出现异常和错误时，仍然能执行 close()。</p>
<h3 id="缓存与批量处理">缓存与批量处理</h3><p>当我想要一次 RPC 请求可以获取多行数据时，可以使用<strong>扫描器缓存</strong>，默认情况下，这个缓存是关闭的。</p>
<p>可以在连个层面上打开它：在表的层面，这个表所有扫描实例的缓存都会生效：也可以在扫描层面，这样便只会影响当前的扫描实例。用户可以使用以下的 HTable 方法设置表级的扫描器缓存：</p>
<pre><code>void <span class="function"><span class="title">setScannerCaching</span><span class="params">(int scannerCaching)</span></span>
int <span class="function"><span class="title">getScannerCaching</span><span class="params">()</span></span>
</code></pre><p>用户可以修改整个 HBase 集群的默认值1，只要把下面的配置项添加到 hbase-site.xml 中即可。</p>
<pre><code><span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.client.scanner.caching<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>10<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</code></pre><p>可以使用下列 Scan 类的方法设置扫描级别的缓存：</p>
<pre><code>void <span class="function"><span class="title">setCaching</span><span class="params">(int caching)</span></span>
int <span class="function"><span class="title">getCaching</span><span class="params">()</span></span>
</code></pre><p><strong>注意</strong>：扫描层面的配置高于表层面的配置，这两种方法能控制每次RPC调用取回的行数。</p>
<p>我们之前介绍的了如何使用客户端的扫描器缓存来从远程 region 服务器向客户端整批传输数据，不过还有一件事需要注意：数据量非常大的行，这些行有可能超过客户端进程的内存容量。HBase 和它的客户端 API 对这个问题有一个解决方法：批量。用户可以使用以下方法控制批量获取操作：</p>
<pre><code>void <span class="function"><span class="title">setBatch</span><span class="params">(int batch)</span></span>
int <span class="function"><span class="title">getBatch</span><span class="params">()</span></span>
</code></pre><p>缓存是面向行一级的操作，而批量则是面向列一级的操作。批量可以让用户选择每一次 ResultScanner 实例的 next() 操作要取回多少列。例如，在扫描中设置 setBatch(5)，则一次 next() 返回的 Result 实例会包括 5 列。</p>
<p>通过组合使用扫描器缓存和批量大小，可以让用户方便地控制一个范围内的行键时所需要的 RPC 调用次数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="PengShuang" />
          <p class="site-author-name" itemprop="name">PengShuang</p>
          <p class="site-description motion-element" itemprop="description">在路上，慢慢走！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">54</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/pengshuang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2176899852/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lingyu.wang/" title="天镶的博客" target="_blank">天镶的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.dongwm.com" title="小明明的博客" target="_blank">小明明的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PengShuang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pengshuang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("DKbLgBme7UkAx9JX6sM3D4Hj-gzGzoHsz", "GXjJ9Ox3pUGI9PJhm6CNfJGN");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
