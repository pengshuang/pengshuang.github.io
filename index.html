<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在路上，慢慢走！">
<meta property="og:type" content="website">
<meta property="og:title" content="小沙文的博客">
<meta property="og:url" content="http://pengshuang.space/index.html">
<meta property="og:site_name" content="小沙文的博客">
<meta property="og:description" content="在路上，慢慢走！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小沙文的博客">
<meta name="twitter:description" content="在路上，慢慢走！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://pengshuang.space/"/>

  <title> 小沙文的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小沙文的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/27/面试排序算法总结/" itemprop="url">
                  面试排序算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-27T09:15:16+08:00" content="2016-09-27">
              2016-09-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试总结/" itemprop="url" rel="index">
                    <span itemprop="name">面试总结</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/27/面试排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/27/面试排序算法总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_冒泡排序">1. 冒泡排序</h3><p>冒泡排序的原理就是重复的去遍历要排序的数列，一次比较2个元素，如果它们顺序错误就把它们交换过来。</p>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span>
    n = len(arry)   <span class="comment"># 获得数组的长度</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):
            <span class="keyword">if</span> arry[i] &gt; arry[j]:   <span class="comment"># 如果前者比后者大</span>
                arry[i], arry[j] = arry[j], arry[i] <span class="comment"># 则互相交换</span>
    <span class="keyword">return</span> arry
</code></pre><h3 id="2-_选择排序">2. 选择排序</h3><p>选择排序的思想比较简单，先在未排序的序列中找到最大（最小）的元素，存放到排序序列的起始位置；再从剩余未排序的序列中寻找最大（最小）的元素，然后放到已排序序列的末尾；以此类推。</p>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arry)</span>:</span>
n = len(arry)
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):
    min = i     <span class="comment"># 先假定第一个为最小元素</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):
        <span class="keyword">if</span> arry[j] &lt; arry[min]:
            min = j     <span class="comment"># 找到最小值的下标</span>
    arry[min], arry[i] = arry[i], arry[min]
<span class="keyword">return</span> arry
</code></pre><h3 id="3-_插入排序">3. 插入排序</h3><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arry)</span>:</span>
    n = len(arry)
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):
        <span class="keyword">if</span> arry[i] &lt; arry[i-<span class="number">1</span>]:
            temp = arry[i]
            index = i   <span class="comment"># 待插入的下标</span>
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 从i-1 循环到 0 (包括0)</span>
                <span class="keyword">if</span> arry[j] &gt; temp:
                    arry[j+<span class="number">1</span>] = arry[j]
                    index = j
                <span class="keyword">else</span>:
                    <span class="keyword">break</span>
            arry[index] = temp
    <span class="keyword">return</span> arry
</code></pre><h3 id="4-_希尔排序">4. 希尔排序</h3><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code><span class="number">13</span> <span class="number">14</span> <span class="number">94</span> <span class="number">33</span> <span class="number">82</span>
<span class="number">25</span> <span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">23</span>
<span class="number">45</span> <span class="number">27</span> <span class="number">73</span> <span class="number">25</span> <span class="number">39</span>
<span class="number">10</span>
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code><span class="number">10</span> <span class="number">14</span> <span class="number">73</span> <span class="number">25</span> <span class="number">23</span>
<span class="number">13</span> <span class="number">27</span> <span class="number">94</span> <span class="number">33</span> <span class="number">39</span>
<span class="number">25</span> <span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">82</span>
<span class="number">45</span>
</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code><span class="number">10</span> <span class="number">14</span> <span class="number">73</span>
<span class="number">25</span> <span class="number">23</span> <span class="number">13</span>
<span class="number">27</span> <span class="number">94</span> <span class="number">33</span>
<span class="number">39</span> <span class="number">25</span> <span class="number">59</span>
<span class="number">94</span> <span class="number">65</span> <span class="number">82</span>
<span class="number">45</span>
</code></pre><p>排序之后变为：</p>
<pre><code><span class="number">10</span> <span class="number">14</span> <span class="number">13</span>
<span class="number">25</span> <span class="number">23</span> <span class="number">33</span>
<span class="number">27</span> <span class="number">25</span> <span class="number">59</span>
<span class="number">39</span> <span class="number">65</span> <span class="number">73</span>
<span class="number">45</span> <span class="number">94</span> <span class="number">82</span>
<span class="number">94</span>
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(arry)</span>:</span>
    n = len(arry)
    gap = n/<span class="number">2</span>    <span class="comment"># 初始步长</span>
    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:
        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):     <span class="comment"># 对每一列进行插入排序, 从gap 到 n-1</span>
            temp = arry[i]
            j = i
            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arry[j-gap] &gt; temp: <span class="comment"># 插入排序</span>
                arry[j] = arry[j-gap]
                j -= gap
            arry[j] = temp
        gap /= <span class="number">2</span>
    <span class="keyword">return</span> arry
</code></pre><h3 id="5-_归并排序">5. 归并排序</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<p>代码实现：</p>
<pre><code>def merge(left, right):
    l, r = <span class="number">0</span>, <span class="number">0</span>
    <span class="literal">result</span> = []
    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):
      <span class="keyword">if</span> left[l] &lt; right[r]:
          <span class="literal">result</span>.append(left[l])
          l += <span class="number">1</span>
      <span class="keyword">else</span>:
          <span class="literal">result</span>.append(right[r])
          r += <span class="number">1</span>
    <span class="literal">result</span> += left[l:]
    <span class="literal">result</span> += right[r:]
    <span class="keyword">return</span> <span class="literal">result</span>

def merge_sort(arry):
    n = len(arry)
    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:
        <span class="keyword">return</span> arry
    num = n/<span class="number">2</span>
    left = merge_sort(arry[:num])
    right = merge_sort(arry[num:])
    <span class="keyword">return</span> merge(left, right)
</code></pre><h3 id="6-_快速排序">6. 快速排序</h3><p>快速排序是面试中被考的频率最高的排序算法了。快速排序通常明显比同为Ο(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素作为基准数。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>
<li>再对左右区间递归执行第二步，直至各区间只有一个数</li>
</ol>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arry)</span>:</span>
    <span class="keyword">return</span> qsort(arry, <span class="number">0</span>, len(arry)-<span class="number">1</span>)

<span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(arry, left, right)</span>:</span>
    <span class="comment"># arry为待排序数组,left为该数组左边界,right为该数组右边界</span>
    <span class="keyword">if</span> left &gt;= right:
        <span class="keyword">return</span> arry
    <span class="comment"># 取最左边的数为基准数</span>
    key = arry[left]
    lp = left
    rp = right
    <span class="keyword">while</span> lp &lt; rp:
        <span class="keyword">while</span> arry[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp:
            rp -= <span class="number">1</span>
        <span class="keyword">while</span> arry[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp:
            lp += <span class="number">1</span>
        arry[lp], arry[rp] = arry[rp], arry[lp]
    arry[left], arry[rp] = arry[rp], arry[left]
    qsort(arry, left, lp - <span class="number">1</span>)
    qsort(arry, rp + <span class="number">1</span>, right)
    <span class="keyword">return</span> arry
</code></pre><h3 id="7-_堆排序">7. 堆排序</h3><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树。</p>
<p>二叉堆具有以下性质：</p>
<ol>
<li><p>父节点的键值总是大于或等于(小于或等于)任何一个子节点的键值。</p>
</li>
<li><p>每个节点的左右子树都是一个二叉堆(都是最大堆或最小堆)。</p>
</li>
</ol>
<p>步骤：</p>
<ol>
<li><p>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
</li>
<li><p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
</li>
<li><p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</p>
</li>
</ol>
<p>代码实现：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span> :</span>
    n = len(ary)
    <span class="comment"># 最后一个非叶子节点</span>
    first = int(n/<span class="number">2</span>-<span class="number">1</span>)
    <span class="comment"># 构造大根堆</span>
    <span class="keyword">for</span> start <span class="keyword">in</span> range(first, -<span class="number">1</span>, -<span class="number">1</span>):     
        max_heapify(ary, start, n-<span class="number">1</span>)
    <span class="keyword">for</span> end <span class="keyword">in</span> range(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):
        <span class="comment"># 堆排，将大根堆转换成有序数组</span>
        ary[end], ary[<span class="number">0</span>] = ary[<span class="number">0</span>], ary[end]
        max_heapify(ary, <span class="number">0</span>, end-<span class="number">1</span>)
    <span class="keyword">return</span> ary

<span class="string">'''
最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点
start为当前需要调整最大堆的位置，end为调整边界
'''</span>
<span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary, start, end)</span>:</span>
    root = start
    <span class="keyword">while</span> <span class="keyword">True</span>:
        <span class="comment"># 调整节点的子节点</span>
        child = root*<span class="number">2</span> + <span class="number">1</span>
        <span class="keyword">if</span> child &gt; end:
            <span class="keyword">break</span>
        <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>]:
            <span class="comment"># 取较大的子节点</span>
            child += <span class="number">1</span>
        <span class="comment"># 较大的子节点成为父节点</span>
        <span class="keyword">if</span> ary[root] &lt; ary[child]:
            <span class="comment"># 交换</span>
            ary[root], ary[child] = ary[child], ary[root]
            root = child
        <span class="keyword">else</span>:
            <span class="keyword">break</span>
</code></pre><h3 id="8-_总结">8. 总结</h3><p>下面为七种经典排序算法指标对比情况：</p>
<p><img src="/img/classicalsort.png" alt=""></p>
<h3 id="9-_参考资料">9. 参考资料</h3><ul>
<li><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">经典排序算法总结与实现</a></p>
</li>
<li><p><a href="http://blog.csdn.net/morewindows/article/details/7961256" target="_blank" rel="external">白话经典算法系列</a></p>
</li>
</ul>
<p>注：本文所有源代码已共享到<a href="https://github.com/pengshuang/Leetcode/tree/master/classical%20alogrithm" target="_blank" rel="external">GitHub</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/26/TCP学习-三/" itemprop="url">
                  IP协议学习(三):路由控制和IPv4数据包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-26T18:47:11+08:00" content="2016-09-26">
              2016-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/26/TCP学习-三/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/26/TCP学习-三/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_路由控制表">1. 路由控制表</h3><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址，即最长匹配。</p>
<h3 id="2-_默认路由">2. 默认路由</h3><p>如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费。这时，默认路由是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。</p>
<h3 id="3-_主机路由">3. 主机路由</h3><p>“IP地址/32” 也被称为主机路由。例如，192.168.153.15/32 就是一种主机路由。它的意思是整个IP地址的所有位都将参与路由。进行主机路由，意味着要基于主机上网卡上配置的IP地址本身，而不是基于该地址的网络地址部分进行路由。</p>
<h3 id="4-_环回地址">4. 环回地址</h3><p>环回地址是同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址具有相同意义的一个叫做localhost的主机名。使用这个IP或主机名时，数据包不会流向网络。</p>
<h3 id="5-_路由控制表的聚合">5. 路由控制表的聚合</h3><p>利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是同一个网络地址。这样可以更好的构建网络，通过路由信息的聚合可以有效地减少路由表的条目。下图展示一个简单的路由聚合的例子。</p>
<p><img src="/img/juhe.png" alt=""></p>
<h3 id="6-_IPv4首部">6. IPv4首部</h3><p>IP首部包含着用于IP协议进行发包控制时所有的必要信息。下图展示了一个IP数据包格式(IPv4)。</p>
<p><img src="/img/ipv4.png" alt=""></p>
<p>下面对IP首部各部分一一进行介绍。</p>
<h4 id="（1）版本">（1）版本</h4><p>没什么实际意义。。。忽略</p>
<h4 id="（2）首部长度">（2）首部长度</h4><p>由4比特构成，表明IP首部的大小，单位为4字节(32比特)，对应没有可选项的IP包，首部长度则设置为5，即没有可选项时，IP首部的长度为20字节(4*5=20)。</p>
<h4 id="（3）区分服务（TOS）">（3）区分服务（TOS）</h4><p>由8比特构成，用来表明服务质量。用0、1、2这三位来表示0~7的优先度。从0到7表示优先度从低到高。每一位具体含义如下所示。</p>
<p><img src="/img/tos.png" alt=""></p>
<h4 id="（4）总长度（Total_Length）">（4）总长度（Total Length）</h4><p>表示IP首部与数据部分合起来的总字节数。该字段长16比特。因此IP包的最大长度为65535。</p>
<h4 id="（5）标识_（ID：Identification）">（5）标识 （ID：Identification）</h4><p>由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，没发送一个IP包，它的值也逐渐递增。此外，即使ID相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</p>
<h4 id="（6）标志（Flags）">（6）标志（Flags）</h4><p>由3比特构成，表示包被分片的相关信息。每一位的具体含义如下：</p>
<table>
<thead>
<tr>
<th>比特</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>未使用</td>
</tr>
<tr>
<td>1</td>
<td>指示是否进行分片。0-可以分片；1-不能分片</td>
</tr>
<tr>
<td>2</td>
<td>包被分片的情况下，表示是否为最后一个包。0-最后一个分片的包；1-分片中段的包</td>
</tr>
</tbody>
</table>
<h4 id="（7）片偏移（FO:_Fragment_Offset)">（7）片偏移（FO: Fragment Offset)</h4><p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192个相对位置。单位为8字节，因此最大可以表示原始数据为65536字节。</p>
<h4 id="（8）生存时间_(TTL)">（8）生存时间 (TTL)</h4><p>由8比特构成，在实际中表示可以中转多少个路由器。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</p>
<h4 id="（9）协议（Protocol）">（9）协议（Protocol）</h4><p>由8比特构成，表示IP首部的下一个首部隶属于哪个协议。</p>
<h4 id="（10）首部校验和">（10）首部校验和</h4><p>由16比特（2个字节构成），也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将校验和的所有位置设置为0，然后以16比特为单位划分IP首部，并用1补数计算所有16位字的和。最后将所得到这个和1的补数赋给首部校验和字段。</p>
<h4 id="（11）源地址">（11）源地址</h4><p>由32位比特（4个字节）构成，表示发送端IP地址。</p>
<h4 id="（12）目标地址">（12）目标地址</h4><p>由32位比特（4个字节）构成，表示接收端IP地址。 </p>
<h4 id="（13）数据">（13）数据</h4><p>存入数据。将IP上层协议的首部也作为数据进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/25/IP地址基础知识/" itemprop="url">
                  IP协议学习(二):IP地址基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-25T21:15:14+08:00" content="2016-09-25">
              2016-09-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/25/IP地址基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/25/IP地址基础知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在TCP/IP通信时，用IP地址识别主机和路由器。为了保证正常通信，有必要为每个设备识别主机和路由器。在互联网通信中，全世界都必须设定正确的IP地址。否则，根本无法实现正常的通信。</p>
<h3 id="1-_IP地址的定义">1. IP地址的定义</h3><p>IP地址（IPv4）由32位正整数来表示。TCP/IP通信要求将这样的IP地址分配给每一个参与通信的主机。</p>
<p>IP地址由 ”网络标识（网络地址）” 和 “主机标识（主机地址）”两部分组成。如下图所示，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的 “主机标识” 则不允许在同一个网段内重复出现。</p>
<p>通过下图也可以看出，IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。网络标识和主机标识通常通过子网掩码（网络前缀）区分。</p>
<p><img src="/img/IPnet.png" alt=""></p>
<h3 id="2-_IP地址的分类">2. IP地址的分类</h3><p><img src="/img/IPaddress.png" alt=""></p>
<p>IP地址分为四个级别，分为A类，B类，C类，D类。它根据IP地址中从第1位到第4位的比特列对网络标识和主机标识进行区分。</p>
<h4 id="A类地址">A类地址</h4><p>A类IP地址是首位以 “0” 开头的地址。从第1位到第8位是它的网络标识。用十进制表示的话，0.0.0.0 ~ 127.0.0.0 是A类的网络地址。A类地址的后24位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16，777，214个。</p>
<h4 id="B类地址">B类地址</h4><p>B类IP地址是前两位为 “10” 的地址。从第1位到第16位是它的网络标识。用十进制表示的话，128.0.0.1 ~ 191.255.0.0是B类的网络地址。B类网络地址的后16位相当于主机标识。因此，一个网段内可容纳的主机上限为65，534个。</p>
<h4 id="C类地址">C类地址</h4><p>C类IP地址是前三位为 “110” 的地址。从第1位到第24位是它的网络标识。用十进制表示的话，192.168.0.0 ~ 239.255.255.0 是C类的网络地址。C类地址的后8位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</p>
<h4 id="D类地址">D类地址</h4><p>D类IP地址是前四位为 “1110” 地址。从第1位到第32位是它的网络标识。用十进制表示的话，224.0.0.0 ~ 239.255.255.255 是D类的网络地址。D类地址没有主机标识，常被用于多播。</p>
<p><strong>注意</strong></p>
<p>主机地址全部为0只有在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。</p>
<h3 id="3-_广播地址">3. 广播地址</h3><p>广播地址用于在同一个链路中相互连接的主机之间发生数据。IP地址中的主机地址部分全部设置为1，就成了广播地址。</p>
<p>广播地址分为本地广播和直接广播两种。在本网络内的广播为本地广播，这个广播地址的IP包会被路由器屏蔽；在不同网络之间的广播叫做之间广播。</p>
<h3 id="4-_IP多播">4. IP多播</h3><h4 id="同时发送提供效率">同时发送提供效率</h4><p>多播用于将包发送给特点组内的所有主机。由于其之间使用IP协议，因此也不存在可靠传输。</p>
<h4 id="IP多播与地址">IP多播与地址</h4><p>多播使用D类地址。因此，如果从首位开始到第4位是“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。</p>
<h3 id="5-_子网掩码">5. 子网掩码</h3><p><img src="/img/mask.png" alt=""></p>
<p>引入了子网以后，一个IP地址就有了两种识别码。一是IP地址本身，另一个是表示网络内部的子网掩码。子网掩码用二进制的方式表示的话，也是一个32位的数字。它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由的定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”。表示方法如下：</p>
<p>IP地址：    172.20.100.52/26</p>
<p>子网掩码：    255.255.255.192</p>
<p>网络地址：  172.20.100.0</p>
<p>广播地址：    172.20.100.63</p>
<p><strong>子网掩码可以灵活的指定网络标识的长度</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/谷歌三篇论文学习-MapReduce/" itemprop="url">
                  谷歌三篇论文学习(一): MapReduce
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T15:05:34+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/论文/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/21/谷歌三篇论文学习-MapReduce/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/21/谷歌三篇论文学习-MapReduce/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="编程模型">编程模型</h3><p><strong>MapReduce</strong>  是一个编程模型，也是一个处理和生产超大数据集的算法模型的相关实现。用户首先创建一个 <strong>Map</strong> 函数处理一个基于 <strong>key/value pair</strong> 的数据集合，输出中间的基于 <strong>key/value pair</strong> 的数据集合；然后再创建一个 <strong>Reduce</strong> 函数来用来合并所有的具有相同中间<strong>key</strong>值的中间<strong>values</strong>值。现实世界中有很多满足上述处理模型的例子。</p>
<p><strong>MapReduce</strong> 编程模型的原理是:利用一个输入 <strong>key/value pair</strong> 集合来产生一个输出的 <strong>key/value pair</strong> 集合。 <strong>MapReduce</strong>  库的用户用两个函数表达这个计算: <strong>Map</strong> 和 <strong>Reduce</strong>。</p>
<p>用户自定义的 <strong>Map</strong> 函数接受一个输入的 <strong>key/value pair</strong> 值,然后产生一个中间 <strong>key/value pair</strong> 值的集合。 <strong>MapReduce</strong> 库把所有具有相同中间 key 值的中间 <strong>value</strong> 值集合在一起后传递给 <strong>Reduce</strong> 函数。</p>
<p>用户自定义的 <strong>Reduce</strong> 函数接受一个中间 <strong>key</strong> 的值和相关的一个 <strong>value</strong> 值的集合。 <strong>Reduce</strong> 函数合并这些 <strong>value</strong> 值，形成一个较小的 <strong>value</strong> 值的集合。一般的，每次 <strong>Reduce</strong> 函数调用只产生 0 或 1 个输出 <strong>value</strong> 值。通 常我们通过一个迭代器把中间 <strong>value</strong> 值提供给 <strong>Reduce</strong> 函数，这样我们就可以处理无法全部放入内存中的大量的 <strong>value</strong> 值的集合。</p>
<pre><code>map(<span class="type">String</span> key, <span class="type">String</span> value):
    // key: document name
    // value: document contents 
    <span class="keyword">for</span> each word w <span class="keyword">in</span> value:
        <span class="type">EmitIntermediate</span>(w, <span class="number">1</span>);

reduce(<span class="type">String</span> key, <span class="type">Iterator</span> values): 
    // key: a word
    // values: a list <span class="keyword">of</span> counts 
    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;
    <span class="keyword">for</span> each v <span class="keyword">in</span> values:
        <span class="literal">result</span> += <span class="type">ParseInt</span>(v); 
    <span class="type">Emit</span>(<span class="type">AsString</span>(<span class="literal">result</span>));
</code></pre><p><strong>Map</strong> 函数输出文档中的每个词、以及这个词的出现次数（在这个简单的例子里就是1）。<strong>Reduce</strong> 函数把Map函数产生的每一个特定的词的计数累加起来。</p>
<h3 id="MapReduce编程模型应用">MapReduce编程模型应用</h3><p>分布式的Grep：Map函数输出匹配模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</p>
<p>计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce 函数把相同的value值都累加起来，产生(URL，记录总数)结果。</p>
<p>倒转网络链接图：Map函数在源页面(source)中搜索所有的链接目标(target)并输出为(target, source)。Reduce 函数把给定链接目标(target)的链接组合成一个列表，输出(target, list(source))。</p>
<p>其他的一些应用场景有，每个主机的检索词向量，倒排索引以及分布式排序。</p>
<h3 id="MapReduce实现">MapReduce实现</h3><p>上图展示了<strong>MapReduce</strong> 实现中操作的全部流程。当用户调用 <strong>MapReduce</strong> 函数时，将发生下面的一 系列动作(下面的序号和图中的序号一一对应):</p>
<ol>
<li><p>用户程序首先调用的 <strong>MapReduce</strong> 库将输入文件分成 M 个数据片度,每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</p>
</li>
<li><p>这些程序副本中的有一个特殊的程序——<strong>master</strong>。副本中其它的程序都是 <strong>worker</strong> 程序，由 <strong>master</strong> 分配 任务。有 M 个 <strong>Map</strong> 任务和 R 个 <strong>Reduce</strong> 任务将被分配，<strong>master</strong> 将一个 <strong>Map</strong> 任务或 <strong>Reduce</strong> 任务分配给一个空闲的 <strong>worker</strong>。</p>
</li>
<li><p>被分配了 <strong>Map</strong> 任务的 <strong>worker</strong> 程序读取相关的输入数据片段，从输入的数据片段中解析出 <strong>key/value pair</strong>，然后把 <strong>key/value pair</strong> 传递给用户自定义的 <strong>Map</strong> 函数，由 <strong>Map</strong> 函数生成并输出的中间 <strong>key/value pair</strong>，并缓存在内存中。</p>
</li>
<li><p>缓存中的 <strong>key/value pair</strong> 通过分区函数分成 R 个区域,之后周期性的写入到本地磁盘上。缓存的 <strong>key/value pair</strong> 在本地磁盘上的存储位置将被回传给 <strong>master</strong>，由 <strong>master</strong> 负责把这些存储位置再传送给 <strong>Reduce worker</strong>。</p>
</li>
<li><p>当 <strong>Reduce worker</strong> 程序接收到 <strong>master</strong> 程序发来的数据存储位置信息后，使用 RPC 从 <strong>Map worker</strong> 所在主机的磁盘上读取这些缓存数据。当 <strong>Reduce worker</strong> 读取了所有的中间数据后，通过对 <strong>key</strong> 进行排序后使得具有相同 <strong>key</strong> 值的数据聚合在一起。由于许多不同的 <strong>key</strong> 值会映射到相同的 <strong>Reduce</strong> 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序,那么就要在外部进行排序。</p>
</li>
<li><p><strong>Reduce worker</strong> 程序遍历排序后的中间数据,对于每一个唯一的中间 <strong>key</strong> 值，<strong>Reduce worker</strong> 程序将这 个 <strong>key</strong> 值和它相关的中间 <strong>value</strong> 值的集合传递给用户自定义的 <strong>Reduce</strong> 函数。<strong>Reduce</strong> 函数的输出被追加到所属分区的输出文件。</p>
</li>
<li><p>当所有的 <strong>Map</strong> 和 <strong>Reduce</strong> 任务都完成之后，<strong>master</strong> 唤醒用户程序。在这个时候,在用户程序里的对 <strong>MapReduce</strong> 调用才返回。</p>
</li>
</ol>
<p>在成功完成任务之后，<strong>Mapreduce</strong> 的输出存放在R个输出文件中（对应每个 <strong>Reduce</strong> 任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件——他们经常把这些文件作为另外一个 <strong>Mapreduce</strong> 的输入， 或者在另外一个可以处理多个分割文件的分布式应用中使用。</p>
<h3 id="Master的数据结构">Master的数据结构</h3><p><strong>Master</strong> 持有一些数据结构，它存储每一个Map和Reduce任务（空闲、工作中或完成），以及Worker机器（非空闲任务的机器）的标识。</p>
<p><strong>Master</strong> 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，<strong>Master</strong> 存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，<strong>Master</strong>接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</p>
<h3 id="容错机制">容错机制</h3><p><strong>Master</strong> 周期性的 ping 每个 <strong>worker</strong>。如果在一个约定的时间范围内没有收到 <strong>worker</strong> 返回的消息，<strong>Master</strong> 将把这个任务标记为失效。所有由这个失效的 <strong>worker</strong> 完成的 <strong>Map</strong> 任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的 <strong>worker</strong>。 同样的，<strong>worker</strong> 失效时正在运行的 <strong>Map</strong> 或 <strong>Reduce</strong> 任务也将被重新置为空闲状态，等待重新调度。</p>
<p>当 <strong>worker</strong> 故障时，由于已经完成的 <strong>Map</strong> 任务的输出存储在这台机器上，<strong>Map</strong> 任务的输出已不接访问了，因此需要重新执行。而已经完成的 Reduce 任务的输出存储在全局文件系统上， 因此不需要再次执行。</p>
<p>当一个 <strong>Map</strong> 任务首先被 <strong>worker A</strong> 执行，之后由于 <strong>worker A</strong> 失效了又被调度到 <strong>worker B</strong> 执行，这个“重新执行”的动作会被通知给所有执行 <strong>Reduce</strong> 任务的 <strong>worker</strong>。任何还没有从 <strong>worker A</strong> 读取数据的 <strong>Reduce</strong> 任务 将从 <strong>worker B</strong> 读取数据。</p>
<p><strong>MapReduce</strong> 可以处理大规模 <strong>worker</strong> 失效的情况。比如，在一个 <strong>MapReduce</strong> 操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，<strong>MapReduce master</strong> 只需要简单的再次执行那些不可访问的 <strong>worker</strong> 完成的工作，之后继续执行未完成的任务，直到最终完成这个 <strong>MapReduce</strong>  操作。</p>
<h3 id="失效方面的处理机制">失效方面的处理机制</h3><p>当用户提供的 <strong>Map</strong> 和 <strong>Reduce</strong> 操作是输入确定性函数(即相同的输入产生相同的输出)时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p>
<p>我们依赖对 <strong>Map</strong> 和 <strong>Reduce</strong> 任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个 <strong>Reduce</strong> 任务生成一个这样的文件，而每个 <strong>Map</strong> 任务则生成 R 个这样的文件(一个 <strong>Reduce</strong> 任务对应一个文件)。当一个 <strong>Map</strong> 任务完成的时，<strong>worker</strong> 发送一个包含 R 个临时文件名的完成消息给 <strong>master</strong>。如果 <strong>master</strong> 从一个已经完成的 <strong>Map</strong> 任务再次接收到到一个完成消息，<strong>master</strong> 将忽略这个消息；否则，<strong>Master</strong> 将这 R 个文件的名字记录在数据结构里。</p>
<p>当 <strong>Reduce</strong> 任务完成时，<strong>Reduce worker</strong> 进程以原子的方式把临时文件重命名为最终的输出文件。如果同 一个 <strong>Reduce</strong> 任务在多台机器上执行,针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文 件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 <strong>Reduce</strong> 任务产生的数据。</p>
<h3 id="分区函数">分区函数</h3><p><strong>MapReduce</strong> 的使用者通常会指定 <strong>Reduce</strong> 任务和 <strong>Reduce</strong> 任务输出文件的数量(R)。我们在中间 key 上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用 <strong>hash</strong> 方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 <strong>key</strong> 值进行的分区将非常有用。比如，输出的 <strong>key</strong> 值是 <strong>URLs</strong>，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，<strong>MapReduce</strong> 库的用户需要􏰁供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的 <strong>URLs</strong> 保存在同一个输出文件中。</p>
<h3 id="顺序保证">顺序保证</h3><p>我们确保在给定的分区中，中间 <strong>key/value pair</strong> 数据的处理顺序是按照 <strong>key</strong> 值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按 <strong>key</strong> 值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p>
<h3 id="Combiner_函数">Combiner 函数</h3><p>在某些情况下，<strong>Map</strong> 函数产生的中间 <strong>key</strong> 值的重复数据会占很大的比重，并且，用户自定义的 <strong>Reduce</strong> 函数满足结合律和交换律。之前举例过的词频统计中，每个 <strong> Map </strong> 任务将产生成千上万个这样的任务<the, 1="">。所有的这些记录将通过网络被发送到一个单独的 <strong>Reduce</strong> 任务，然后这个 <strong>Reduce</strong> 任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的 <strong>combiner</strong> 函数，<strong>combiner</strong> 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</the,></p>
<p><strong>Combiner</strong> 函数在每台执行 <strong>Map</strong> 任务的机器上都会被执行一次。 一般情况下，<strong>Combiner</strong> 和 <strong>Reduce</strong> 函数是一样的。<strong>Combiner</strong> 函数和 <strong>Reduce</strong>函数之间唯一的区别是 <strong>MapReduce</strong> 库怎样控制函数的输出。<strong>Reduce</strong> 函数的输出被保存在最终的输出文件里，而 <strong>Combiner</strong> 函数的输出被写到中间文件里，然后被发送给 <strong>Reduce</strong> 任务。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/IP协议/" itemprop="url">
                  IP协议学习(一):IP基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T16:32:15+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/IP协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/IP协议/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_网络层与数据链路层的关系">1. 网络层与数据链路层的关系</h3><p>数据链路层提供直连两个设备之间的通信功能。与之相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。</p>
<p>数据链路只负责某一个区间之间的通信传输。IP负责将数据包发送给最终的目标地址。即点对点通信。</p>
<p>IP大致分为三大作用模块，它们是IP寻址、路由（最终节点为止的转发）以及IP分包与组包。</p>
<h3 id="2-_IP地址属于网络层地址">2. IP地址属于网络层地址</h3><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。数据链路的MAC地址是用来标识同一个链路中不同计算机的一种标识码。</p>
<p>而作为网络层的IP，我们常称为IP地址，也包含着这样一种地址信息。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP/IP通信中所有的主机或路由器必须设定自己的IP地址。（严格来说，要针对每块网卡至少配置一个或一个以上的IP地址）</p>
<p>不论一台主机与哪种数据链路连接，其IP地址的形式都保持不变。以太网、无线局域网、PPP等，都不会改变IP地址的形式。</p>
<h3 id="3-_路由控制">3. 路由控制</h3><p>路由控制（Routiong）是指将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。因此，一个数据包之所以能够成功第达到最终的目标地址，全靠路由控制。</p>
<p><strong>发送数据至最终目标地址</strong></p>
<p><strong>Hop</strong> 译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。下面这张图形象的表示了包转发的整个过程。</p>
<p><img src="/img/hop.png" alt=""></p>
<p><strong>一跳的范围</strong></p>
<p>一跳（1 Hop）是指利用数据链路层以下分层的功能传输数据帧的一个区间。</p>
<p>以太网等数据链路中使用MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。在一跳的这个区间内，电缆可以通过网桥或交换集线器相连，不会通过路由器或网关相连。</p>
<p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间（跳）在转发IP数据包时会分别指定下一跳的操作，直至包到达最终的目标地址。如果用购买火车票为例来说的话，IP就相当于在每次换乘时购买了标有下一个MAC地址的车票。</p>
<p><strong>路由控制表</strong></p>
<p>为了将数据包发送给目标主机，所有路由器都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。下图是一个路由控制表的示意图。</p>
<p><img src="/img/routing.png" alt=""></p>
<h3 id="4-_数据链路的抽象化">4. 数据链路的抽象化</h3><p>IP是实现多个数据链路之间通信的协议。数据链路根据种类的不同各有特点。对这些不同数据链路的相异特性进行抽象化是IP的重要作用之一。不论底层数据链路使用以太网LAN亦或是PPP，都将被一视同仁。</p>
<p>不同数据链路有个很大的区别，就是它们各自的最大传输单播（MTU）不同。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p>
<p>为了解决这个问题，IP进行分片处理(IP Fragmentation)。所谓分片处理，就是将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。</p>
<h3 id="5-_IP属于面向无连接型">5. IP属于面向无连接型</h3><p>IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。之所以IP要面向无连接，一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。IP在需要有连接时，可以委托上一层提供此服务，因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/hive模式设计/" itemprop="url">
                  《Hive编程指南》学习笔记：Hive模式设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T10:58:22+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/hive模式设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/hive模式设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_按天划分的表">1. 按天划分的表</h3><pre><code>hive&gt; CREATE TABLE supply (id <span class="built_in">int</span>, part <span class="built_in">string</span>, quantity <span class="built_in">int</span>)
    &gt; PARTITIONED BY (<span class="built_in">int</span> <span class="built_in">day</span>);

hive&gt; ALTER TABLE supply add PARTITION (<span class="built_in">day</span>=<span class="number">20110102</span>)
hive&gt; ALTER TABLE supply add PARTITION (<span class="built_in">day</span>=<span class="number">20110103</span>)
...

hive&gt; .... load data ....

hive&gt; <span class="keyword">SELECT</span> part, quantity FROM supply
    &gt; WHERE <span class="built_in">day</span> &gt;= <span class="number">20110102</span> <span class="keyword">AND</span> <span class="built_in">day</span> &lt; <span class="number">20110103</span> <span class="keyword">AND</span> quantity &lt; <span class="number">4</span>;
</code></pre><h3 id="2-_关于分区">2. 关于分区</h3><p>在Hive中，通过创建分区可以优化一些查询，但如果创建的分区很多很多的话，反而会对其他一些重要的查询不利，因为HDFS用于设计存储数百万的大文件，而非数十亿的小文件。使用过多的分区可能导致的一个问题就是会创建大量的非必须的Hadoop文件和文件夹。</p>
<p>MapReduce 会将一个任务（job）转换为多个任务（task）。默认情况下，每个task都是一个新的JVM实例，都需要开启和销毁的开销。对于小文件来说，每个文件都会对应一个task。在一些情况下，JVM开启和销毁的时间中销毁可能会比实际处理数据的时间消耗更长！</p>
<p>因此，一个理想的分区方案不应该导致产生太多的分区和文件夹目录，并且每个目录下的文件应该足够得大，应该是文件系统中块大小的若干倍。</p>
<p>按时间范围进行分区的一个好的策略就是按照不同的时间粒度来确定合适大小的数据积累量，而且安装这个时间粒度。随着时间的推移，分区数量的增长是“均匀的”，而且每个分区下包含的文件大小至少是文件系统中块的大小的若干倍。这个平衡可以保持使分区足够大，从而优化一般情况下查询的数据吞吐量。同时有必要考虑这中粒度级别在未来是否是适用的，特别是查询中WHERE子句选择较小粒度的范围的情况：</p>
<pre><code>hive&gt; CREATE TABLE weblogs (url <span class="built_in">string</span>, time <span class="built_in">long</span>, state <span class="built_in">string</span>, 
city <span class="built_in">string</span> )
    &gt; PARTITIONED <span class="keyword">BY</span> (day int);
hive&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weblogs <span class="keyword">WHERE</span> day=<span class="number">20110102</span>;
</code></pre><p>也可以使用2个级别的分区，并且适用不同的维度:</p>
<pre><code>hive&gt; CREATE TABLE weblogs (url <span class="built_in">string</span>, time <span class="built_in">long</span>, city <span class="built_in">string</span> )
    &gt; PARTITIONED <span class="keyword">BY</span> (day int, state <span class="built_in">string</span>);
hive&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weblogs <span class="keyword">WHERE</span> day=<span class="number">20110102</span>;
</code></pre><h3 id="3-_唯一键和标准化">3. 唯一键和标准化</h3><p>关系型数据库通常使用唯一键、索引和标准化来存储数据集，通常是全部或者大部分存储到内存的。然而，Hive没有主键或基于序列密钥生成的自增键的概念。</p>
<p>避免标准化的主要原因是为了最小化磁盘寻道，比如那些通常需要外键关系的情况。非标准化数据允许被扫描或写入到大的，连续的磁盘存储区域，从而优化磁盘驱动器的I/O性能。然而，非标准化数据可能导致数据重复，有导致数据不一致的风险。</p>
<h3 id="4-_同一份数据多种处理">4. 同一份数据多种处理</h3><p>Hive 本身提供一个独特的语法，它可以从一个数据源产生多个数据聚合，而无需每次聚合都要重新扫描一次。对于大的数据输入集来说，这个优化可以节约非常可观的时间。</p>
<p>常用的方法：</p>
<pre><code>hive&gt; FROM history
    &gt; INSERT OVERWRITE sales <span class="keyword">SELECT</span> * <span class="keyword">WHERE</span> action=<span class="string">"purchased'
    &gt; INSERT OVERWRITE credits SELECT * WHERE actions="</span>returned<span class="string">';</span>
</code></pre><h3 id="5-_对于每个表的分区">5. 对于每个表的分区</h3><p>很多的ETL处理过程会涉及到多个处理步骤，而每个处理步骤可能会产生一个或多个临时表，这些表仅供下一个job使用。下面的这个例子即在中间表内部使用分区，这样的话就不会再计算某一天的数据时会发生前一天的数据被 <strong>INSERT OVERWRITE</strong> 语句覆盖掉的情况。</p>
<pre><code>$ hive -hiveconf dt=<span class="number">2011</span>-<span class="number">01</span>-<span class="number">01</span>
hive&gt; <span class="type">INSERT</span> <span class="type">OVERWRITE</span> table distinct_ip_logs
    &gt; <span class="type">PARTITION</span> (hit_date=${dt})
    &gt; <span class="type">SELECT</span> <span class="keyword">distinct</span>(ip) <span class="keyword">as</span> ip <span class="keyword">from</span> weblogs
    &gt; <span class="type">WHERE</span> hit_date = '${hiveconf:dt}';

hive&gt; <span class="type">CREATE</span> <span class="type">TABLE</span> state_city_for_day (state <span class="type">string</span>, city <span class="type">string</span>)
    &gt; <span class="type">PARTITIONED</span> <span class="type">BY</span> (hit_date <span class="type">string</span>)

hive&gt; <span class="type">INSERT</span> <span class="type">OVERWRITE</span> table state_city_for_day <span class="type">PARTITION</span>(${hivecong:df})
    &gt; <span class="type">SELECT</span> <span class="keyword">distinct</span>(state, city) <span class="type">FROM</span> distinct_ip_in_logs
    &gt; <span class="type">JOIN</span> geodata <span class="type">ON</span> (distinct_ip_in_logs.ip = geodata.ip)
    &gt; <span class="type">WHERE</span> (hit_date = '${hiveconf:dt}');
</code></pre><p>这种方法有个缺点，就是用户将需要管理中间表并删除旧分区。</p>
<h3 id="6-_分桶表数据存储">6. 分桶表数据存储</h3><p>分区提供一个隔离数据和优化查询的便利的方式。但是并非所有的数据集都可以形成合理的分区，特别是之前所提过的要确定合适的划分大小。</p>
<p>分桶是将数据集分解成更容易管理的若干部分。我们假设有个表的一级分区是dt，代表日期，二级分区是<strong>user_id</strong>，那么这种划分方式可能导致太多的小分区。但是，如果我们对表进行分桶，并使用<strong>user_id</strong>字段作为分桶字段，则字段值会根据用户指定的值进行哈希分发到桶中。同一个<strong>user_id</strong>下的记录通常会存储到同一个桶内。同一个<strong>user_id</strong>下的记录通常会存储到同一个桶内，假设用户数要比桶数多得多，那么每个桶内就将会包含多个用户的记录：</p>
<pre><code>hive&gt; CREATE TABLE weblog (user_id INT, url <span class="built_in">STRING</span>, source_ip <span class="built_in">STRING</span>)
    &gt; PARTITIONED <span class="keyword">BY</span> (dt <span class="built_in">STRING</span>)
    &gt; CLUSTERED <span class="keyword">BY</span> (user_id) <span class="keyword">INTO</span> <span class="number">96</span> BUCKETS;
</code></pre><p>在使用 <strong>INSERT … TABLE</strong> 语句时，我们需要设置一个属性来强制Hive为目标表的分桶初始化过程设置一个正确的reducer个数。然后我们再执行一个查询来填充分区。例如：</p>
<pre><code>hive&gt; <span class="keyword">SET</span> hive.enforce.bucketing = <span class="literal">true</span>

hive&gt; <span class="keyword">FROM</span> raw_logs
    &gt; INSERT OVERWRITE TABLE weblog
    &gt; PARTITION (dt=<span class="string">"2015-01-01"</span>)
    &gt; <span class="keyword">SELECT</span> user_id, url, source_ip <span class="keyword">WHERE</span> dt=<span class="string">"2015-01-01"</span>;
</code></pre><p>如果我们没有使用 <strong>hive.enforce.bucketing</strong> 属性，那么我们就需要自己设置和分桶个数想匹配的 <strong>reducer</strong> 个数。例如，使用 <strong>set.mapred.reduce.tasks=96</strong>，然后在 <strong>INSERT</strong> 语句中，需要在 <strong>SELECT</strong> 语句后增加 <strong>CLUSTER BY</strong> 语句。</p>
<p>分桶有几个优点，因为桶的数量是固定的，所以它没有数据波动，故对于抽样再合适不过。</p>
<h3 id="7-_为表增加列">7. 为表增加列</h3><p>Hive允许在原始数据文件之上定义一个模式，而不像很多的数据库那样，要求必须以特定的格式转换和插入数据。这样的分离方式的好处是，当为数据文件增加新的字段时，可以容易地适应表定义的模式。</p>
<p>下面来举个例子：</p>
<pre><code>hive&gt; CREATE TABLE weblogs (version LONG, url <span class="built_in">STRING</span>)
    &gt; PARTITIONED <span class="keyword">BY</span> (hit_date int)
    &gt; ROW FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">'\t'</span>;

hive&gt; <span class="subst">!</span> cat log1<span class="built_in">.</span>txt
<span class="number">1</span>    /login
<span class="number">1</span>    /logout

hive&gt; LOAD <span class="built_in">DATA</span> <span class="built_in">LOCAL</span> INPATH <span class="string">'log1.txt'</span> int weblogs partition(<span class="number">20150101</span>);

hive&gt; <span class="keyword">SELECT</span> * FROM weblogs;
<span class="number">1</span>    /mystuff    <span class="number">20150101</span>
<span class="number">1</span>    /toys        <span class="number">20150101</span>
</code></pre><p>随着时间的推移，可能会为底层数据增加一个新字段。下面是为数据新增 <strong>user_id</strong>字段的过程。</p>
<pre><code>hive&gt; ! cat log2.txt
<span class="number">2</span>    /cars    bob
<span class="number">2</span>    /stuff    terry

hive&gt; ALTER TABLE weblogs ADD COLUMNS (user_id <span class="built_in">string</span>)<span class="comment">;</span>

hive&gt; LOAD DATA <span class="keyword">LOCAL</span> INPATH <span class="string">'log2.txt'</span> <span class="built_in">int</span> weblogs partition(<span class="number">20150102</span>)<span class="comment">;</span>

hive&gt; <span class="keyword">SELECT</span> * from weblogs
<span class="number">1</span>    /mystuff    <span class="number">20150101</span>     <span class="literal">NULL</span>
<span class="number">1</span>    /toys        <span class="number">20150101</span>    <span class="literal">NULL</span>
<span class="number">2</span>    /cars        <span class="number">20150102</span>     bob
<span class="number">2</span>    /stuff        <span class="number">20150102</span>    terry
</code></pre><p>但是这种方式，无法在已有字段的开始或中间增加新字段。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/HiveQL-视图/" itemprop="url">
                  《Hive编程指南》学习笔记：HiveQL:视图与索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T21:56:00+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/HiveQL-视图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/HiveQL-视图/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>视图可以允许保存一个查询并像对待表一样对这个查询进行操作。这是一个逻辑结构，而非物化的一个表结构。</p>
<h3 id="1-_使用视图来降低查询的复杂度">1. 使用视图来降低查询的复杂度</h3><p>例如，一个具有嵌套子查询的查询：</p>
<pre><code>FROM (
    <span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">JOIN</span> cart
        <span class="keyword">ON</span> (cart.people_id = people.<span class="keyword">id</span>) <span class="keyword">WHERE</span> firstname = <span class="string">'John'</span>
    ) a <span class="keyword">SELECT</span> a.lastname <span class="keyword">WHERE</span> a.<span class="keyword">id</span> = <span class="number">3</span>;</span>
</code></pre><p>将上面这个嵌套子查询变成一个视图：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> shorter_join <span class="keyword">AS</span>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">JOIN</span> cart
<span class="keyword">ON</span> (cart.people_id = people.<span class="keyword">id</span>) <span class="keyword">WHERE</span> firstname=<span class="string">'john'</span>;</span>
</code></pre><p>现在就可以像操作表一样操作这个视图了：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> lastname <span class="keyword">FROM</span> shorter_join <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span>
</code></pre><h3 id="2-_使用视图来限制基于条件过滤的数据">2. 使用视图来限制基于条件过滤的数据</h3><p>视图有一个常见的使用场景就是基于一个或多个列的值来限制输出结果，</p>
<h4 id="(1)_通过视图来限制输入出结果：">(1) 通过视图来限制输入出结果：</h4><pre><code>hive&gt; CREATE TABLE userinfo (
      firstname <span class="built_in">string</span>, lastname <span class="built_in">string</span>, ssn <span class="built_in">string</span>, password <span class="built_in">string</span>);
hive&gt; CREATE VIEW safer_user_info <span class="keyword">AS</span>
      <span class="keyword">SElECT</span> firstname, lastname <span class="keyword">FROM</span> userinfo;
</code></pre><h4 id="(2)_通过使用视图来只暴露部分结果：">(2) 通过使用视图来只暴露部分结果：</h4><pre><code>hive&gt; CREATE TABLE employee (firstname <span class="built_in">string</span>, lastname <span class="built_in">string</span>,
      ssn <span class="built_in">string</span>, password <span class="built_in">string</span>, department <span class="built_in">string</span>);
 hive&gt; CREATE VIEW techops_employee <span class="keyword">AS</span> 
       <span class="keyword">SELECT</span> firstname, lastname,ssn <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> department=<span class="string">"techops"</span>;
</code></pre><h3 id="3-_创建索引">3. 创建索引</h3><p>下面以为一个分区表创建索引为例：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (
    <span class="keyword">name</span>    <span class="keyword">STRING</span>,
    salary    <span class="built_in">FLOAT</span>,
    subordinates    <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,
    deductions    <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>, <span class="built_in">FLOAT</span>&gt;,
    address    <span class="keyword">STRUCT</span>&lt;street:<span class="keyword">STRING</span>, city:<span class="keyword">STRING</span>, state:<span class="keyword">STRING</span>, zip:<span class="built_in">INT</span>&gt;
    )
    PARTITIONED <span class="keyword">BY</span> (country <span class="keyword">STRING</span>, state <span class="keyword">STRING</span>);</span>
</code></pre><p>下面对分区字段country建立索引：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> employees_index
<span class="keyword">ON</span> TBALE employess (country)
<span class="keyword">AS</span> <span class="string">'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler'</span>
<span class="keyword">WITH</span> <span class="keyword">DEFERRED</span> <span class="keyword">REBUILD</span>
IDXPROPERTIES (<span class="string">'creator = '</span>me<span class="string">', '</span>created_at<span class="string">' = '</span>some_time<span class="string">')
IN TABLE employee_index_table
PARTITIONED BY (country_name)
COMMENT '</span>Employees indexed <span class="keyword">by</span> country <span class="keyword">and</span> <span class="keyword">name</span>.<span class="string">';</span></span>
</code></pre><p>如果在这里我省略掉PARTITIONED BY语句的话，那么索引将会包含原始表的所有分区。</p>
<p>AS … 语句指定了索引处理器，也就是一个实现了索引接口的Java类。</p>
<p>如果要求索引处理器在一张新表中保留索引数据，会使用到 IN_TABLE… 子句。</p>
<h4 id="Bitmap_索引">Bitmap 索引</h4><p>如果想使用Bitmap索引，那么将</p>
<pre><code><span class="title">AS</span> <span class="string">'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler'</span>
</code></pre><p>替换为：</p>
<pre><code><span class="title">AS</span> <span class="string">'BITMAP'</span>
</code></pre><p>即可。</p>
<h3 id="4-_重建索引">4. 重建索引</h3><p>如果用户指定了 <strong>DEFERRED REBUILD</strong>， 那么新索引将呈现空白状态。在任何时候，都可以进行第一次索引创建或者使用ALTER INDEX对索引进行重建。</p>
<pre><code><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> employees_index
<span class="keyword">ON</span> <span class="keyword">TABLE</span> employees
<span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>)
<span class="keyword">REBUILD</span></span>
</code></pre><p>如果省略掉PARTITION，那么将会对所有分区进行重建索引。</p>
<h3 id="5-_显示索引">5. 显示索引</h3><pre><code><span class="operator"><span class="keyword">SHOW</span> (FORMATTED) <span class="keyword">INDEX</span> <span class="keyword">on</span> employees;</span>
</code></pre><p>关键字FORMATTED是可选的。增加这个关键字可以使输出中包含有列名称。用户还可以替换INDEX为INDEXES，这样输出中就可以列举多个索引信息了。</p>
<h3 id="6-_删除索引">6. 删除索引</h3><p>如果有索引表的话，删除一个索引将会删除这个索引表：</p>
<pre><code><span class="operator"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> employees_index <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees;</span>
</code></pre><p>Hive不允许用户直接使用 <strong>DROP TABLE</strong> 语句之前删除索引表。如果被索引的表被删除了，那么其对应的索引和索引表也会被删除。如果原始表的某个分区被删除了，那么这个分区对应的分区索引也同时会被删除掉。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/TCP-IP基础知识/" itemprop="url">
                  TCP/IP协议分层模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T22:01:00+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/15/TCP-IP基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/15/TCP-IP基础知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_物理层（硬件）">1. 物理层（硬件）</h3><p>TCP/IP的最底层是负责数据传输的硬件。</p>
<h3 id="2-_数据链路层（网络接口层）">2. 数据链路层（网络接口层）</h3><p>数据链路层利用以太网中的数据链路层进行通信，因此属于接口层。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p>
<h3 id="3-_网络层（互联网层）">3. 网络层（互联网层）</h3><p>网络层使用IP协议，它相当于OSI模型中的第三层网络层。IP协议基于IP地址转发分包数据。TCP/IP分层中的网络层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过网络层转发分组数据包的功能。</p>
<h4 id="IP">IP</h4><p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间使用IP地址作为主机的标识。虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输。</p>
<h4 id="ICMP">ICMP</h4><p>IP数据包在发送途中一旦发送异常导致无法到达对端目标地址时，需要给发送端发送一个发送异常的通知。ICMP就是被用来诊断网络的健康状况。</p>
<h4 id="ARP">ARP</h4><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p>
<h3 id="4-_传输层">4. 传输层</h3><p>传输层主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的事端口号。</p>
<h4 id="TCP">TCP</h4><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p>
<h4 id="UDP">UDP</h4><p>UDP有别于TCP，它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据。UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p>
<h3 id="5-_应用层（会话层以上的分层）">5. 应用层（会话层以上的分层）</h3><p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。</p>
<p>HTTP协议属于应用层的协议，HTML和电子邮件属于表示层协议。</p>
<h3 id="6-_TCP/IP分层模型及通信示例">6. TCP/IP分层模型及通信示例</h3><p>以甲向乙发送电子邮件为例，来讲解TCP/IP的通信过程。</p>
<h4 id="应用程序处理">应用程序处理</h4><p>启动应用新建邮件，填写好内容并点击发送之后，应用程序会进行编码处理，这些编码相当于OSI的表示层的功能。编码转化后，实际邮件不一定会马上被发送出去，因为有些邮件的软件有一次同时发送多个邮件的功能。像这种何时建立通信连接何时发送数据的管理功能，其实属于OSI参考模型中会话层的功能。</p>
<p>应用在发送电子邮件的那一刻建立TCP连接，从而利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，再做实际的转发处理。</p>
<h4 id="TCP模块的处理">TCP模块的处理</h4><p>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号。（用以识别发送主机跟接收主机上的应用）、序号（用以发送的包中哪部分是数据）以及校验和（用以判断数据是否被损坏）。随后将附加了TCP首部的包再发送给IP。</p>
<h4 id="IP模块的处理">IP模块的处理</h4><p>IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端加上自己的IP首部。因此，IP数据包中的IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据是TCP还是UDP的信息。</p>
<h4 id="网络接口（以太网驱动）的处理">网络接口（以太网驱动）的处理</h4><p>从IP传过来的IP包，对于以太网驱动来说不过就是数据。给这数据附上以太网首部并进行发送处理。以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端。</p>
<h4 id="经过数据链路的包">经过数据链路的包</h4><p>每个包首部中至少都会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。经过每个协议分层时，都必须有识别包发送端和接收端的信息。以太网会用MAC地址，IP会用IP地址，而TCP/UDP会用端口号作为识别两端主机的地址。分层中包的结构如下所示：</p>
<p><img src="/img/tcp.png" alt=""></p>
<p>此外每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP/UDP中两个端口的端口号都起着识别协议类型的作用。</p>
<h4 id="数据包接收处理">数据包接收处理</h4><p>包的接收流程是发送流程的逆序过程。</p>
<h4 id="网络接口（以太网驱动）的处理-1">网络接口（以太网驱动）的处理</h4><p>主机收到以太网包以后，首先从以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是则丢弃。而如果接收到了恰好是发送给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型（IP或其他诸如ARP的协议）。如果以太网首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p>
<h4 id="IP模块的处理-1">IP模块的处理</h4><p>IP模块收到IP包首部以及后面的数据部分后，如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议。如果上一层是TCP就将IP包首部之后的传给TCP处理；UDP类似。对于有路由器的情况，接收端地址往往不是自己的地址，此时需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。</p>
<h4 id="TCP模块的处理-1">TCP模块的处理</h4><p>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按序号接收数据。最后检查端口号，确定具体的应用程序。数据接收完毕之后，接收端返回一个“确认回执”给发送端。</p>
<p>数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<h4 id="应用程序的处理">应用程序的处理</h4><p>接收端应用程序会直接接收发送端发送的数据，如果确认是发送给自己的，则邮件会被保存到本机的硬盘上。如果保存能正常进行，那么会返回给一个“处理正常”的回执给发送端。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/理解有连接和无连接/" itemprop="url">
                  理解计算机网络中的传输方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T09:05:01+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/15/理解有连接和无连接/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/15/理解有连接和无连接/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_面向有连接型与面向无连接型">1. 面向有连接型与面向无连接型</h3><p>通过网络发送数据，大致可以分为面向有连接与面向无连接类型</p>
<p>(1) 面向无连接型包括以太网、IP、UDP等协议。</p>
<p>(2) 面向有连接型包括ATM、帧中继、TCP。</p>
<h4 id="面向有连接型">面向有连接型</h4><p>面向有连机型中，在发送数据之前，需要在收发主机之间连接一条通信线路。并且必须在通信传输前后，专门进行建立和断开连接的处理。如果与对端之间无法通信，就可以避免发送无谓的数据</p>
<h4 id="面向无连接型">面向无连接型</h4><p>面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据。反之，接收端也永远不知道自己会在何时从哪里接收到数据。</p>
<h3 id="2-_电路交换与分组交换">2. 电路交换与分组交换</h3><h4 id="电路交换">电路交换</h4><p>计算机之间在发送数据时，需要通过交换机与目标主机建立通信电路。我们将连接电路称为建立连接。建立好连接以后，用户就可以一直使用这条电路，直到该连接被断开为止。</p>
<h4 id="分组交换">分组交换</h4><p>在分组交换中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。因此，分组交换也有另一个名称：蓄积交换。</p>
<p>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条共享线路。</p>
<h3 id="3-_根据接收端数量分类">3. 根据接收端数量分类</h3><p>网络通信中，也可以根据目标地址的个数以及后续的行为对通信进行分类。如广播、多播等。</p>
<h4 id="单播（Unicast）">单播（Unicast）</h4><p>1对1通信</p>
<h4 id="广播（Broadcast）">广播（Broadcast）</h4><p>广播指将消息从1台主机发送给与之相连的所有其他主机。典型的例子是电视播放。</p>
<h4 id="多播（Multicast）">多播（Multicast）</h4><p>多播与广播类似，也是将消息发送给多个接收主机。不同之处在于多播要限定某一组作为接收端。多播通信最典型的例子是电视会议。</p>
<h4 id="任播_（Anycast）">任播 （Anycast）</h4><p>任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/OSI7层通信模型/" itemprop="url">
                  OSI7层通信模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T22:32:15+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/OSI7层通信模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/OSI7层通信模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>理解TCP/IP的7层模型，可以从每一层的功能入手，每个分层上的协议规定了该分层中数据首部的格式已经首部与处理数据的顺序。下面以一个实际应用：主机A向主机B发送邮件来解释7层通信模型。</p>
<h3 id="1-_应用层">1. 应用层</h3><p>应用层为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议。两个要通信的主机之间通过它们各自的应用层进行通信，最终实现主机A向主机B发送邮件，以及邮件的存储。</p>
<h3 id="2-_表示层">2. 表示层</h3><p>将数据从主机特有的格式转换为网络标准传输格式，数据被转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复为“该计算机特定的数据格式”，然后再进行相应处理。 这样使得异构的机型之间能保持数据一致性。表示层是进行“统一的网络数据格式”与“某一台计算机或一款软件特有的数据格式”之间相互转换的分层。</p>
<h3 id="3-_会话层">3. 会话层</h3><p>决定采用哪种连接方法是会话层的主要责任。会话层也想应用层或表示层那样，在其收到的数据前端附加首部或标签信息后再转发给下一层。而这些首部或标签中记录着数据传送顺序的信息。</p>
<h3 id="4-_传输层">4. 传输层</h3><p>会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理。会话层只对何时建立连接、何时发送数据等问题进行管理，并不具有实际传输数据的功能。真正负责在网络上传输具体数据的是会话层以下的各层。</p>
<p>进行建立连接或断开连接处理，在两个主机之间创建逻辑上的通信连接即是传输层的主要作用。此外，传输层为确保所传输的数据到达目标地址，会在通信两端的计算机之间进行确认，如果数据没有到达，则要负责进行重传。未来确保可靠性，在这一层也会为所要传输的数据附加首部以识别这一分层的数据。实际将传输给对端的处理是由网络层来完成的。</p>
<h3 id="5-_网络层">5. 网络层</h3><p>从主机A到主机B的数据通信处理。网络层的作用是在网络与网络相互连接的环境中，将数据从发生端主机发送到接收端主机。网络层负责将数据发送至最终目标地址，数据链路层负责实现每一个区间内的通信。</p>
<h3 id="6-_数据链路层">6. 数据链路层</h3><p>通信传输实际上是通过物理的传输介质实现的。数据链路层的作用是在这些通过传输介质相互连接的设备之间进行数据处理。网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p>
<h3 id="7-_物理层">7. 物理层</h3><p>将数据的0、1转换为电压和脉冲光传输给物理的传输介质，而相互直连的设备之间使用地址实现传输。这种地址被称为MAC地址，也可称为物理地址。</p>
<h3 id="8-_接收端的处理">8. 接收端的处理</h3><p>接收端从物理层开始接收到的数据逐层发送给上一分层进行处理，从而使用户最终接收到发送端发送过来的信息。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="PengShuang" />
          <p class="site-author-name" itemprop="name">PengShuang</p>
          <p class="site-description motion-element" itemprop="description">在路上，慢慢走！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/pengshuang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2176899852/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lingyu.wang/" title="天镶的博客" target="_blank">天镶的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PengShuang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pengshuang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
