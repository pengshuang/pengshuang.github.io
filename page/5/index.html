<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在路上，慢慢走！">
<meta property="og:type" content="website">
<meta property="og:title" content="小沙文的博客">
<meta property="og:url" content="http://pengshuang.space/page/5/index.html">
<meta property="og:site_name" content="小沙文的博客">
<meta property="og:description" content="在路上，慢慢走！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小沙文的博客">
<meta name="twitter:description" content="在路上，慢慢走！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://pengshuang.space/page/5/"/>

  <title> 小沙文的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小沙文的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/分布式系统学习-一致性协议/" itemprop="url">
                  分布式系统学习: 2PC 与 3PC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-24T15:09:41+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/24/分布式系统学习-一致性协议/" class="leancloud_visitors" data-flag-title="分布式系统学习: 2PC 与 3PC">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在对一个分布式系统进行架构设计的过程中、往往会在系统的可用性和数据一致性之间进行反复的权衡，于是就产生了一系列的一致性协议。其中最近经典的就是二阶段提交协议、三阶段提交协议和Paxos算法了。</p>
<h3 id="2PC-与-3PC"><a href="#2PC-与-3PC" class="headerlink" title="2PC 与 3PC"></a>2PC 与 3PC</h3><p>在分布式系统中，每一个机器节点虽然能够明确知道自己在进行事务操作中的结果是成功或失败，但却无法直接获取到其他分布式结点的操作结果。因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个称为“协调者”的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为“参与者”，协调者辅助调度参与者的行为，并最终决定这些参与者是否要把事务真正的提交。基于这个思想，衍生出了二阶段提交(2PC)和三阶段提交(3PC)两种协议。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>2PC是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效的保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。</p>
<h4 id="协议说明"><a href="#协议说明" class="headerlink" title="协议说明"></a>协议说明</h4><p>二阶段协议将事务的提交过程分成两个阶段来进行处理。</p>
<h4 id="阶段一：提交事务请求"><a href="#阶段一：提交事务请求" class="headerlink" title="阶段一：提交事务请求"></a>阶段一：提交事务请求</h4><ol>
<li><p>事务询问</p>
<p> 协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>执行事务</p>
<p> 各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应</p>
<p> 如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者 No 响应，表示事务不可以执行。</p>
</li>
</ol>
<h4 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h4><p>阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包括两种可能。</p>
<p><strong>执行事务提交</strong></p>
<p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务提交。</p>
<ol>
<li><p>发送提交请求</p>
<p> 协调者向所有参与者结点发出 Commit 请求。</p>
</li>
<li><p>事务提交</p>
<p> 参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</p>
</li>
<li><p>反馈事务提交结果</p>
<p> 参与者在完成事务提交之后，向协调者发送 ACK 消息。</p>
</li>
<li><p>完成事务。</p>
<p> 协调者接收到所有参与者反馈的 ACK 消息后，完成事务。</p>
</li>
</ol>
<p><strong>中断事务</strong></p>
<p>假如任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li><p>发送回滚请求</p>
<p> 协调者向所有参与者节点发送 Rollback 请求。</p>
</li>
<li><p>事务回滚</p>
<p> 参与者接收到 Rollback请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</p>
</li>
<li><p>反馈事务回滚结果</p>
<p> 参与者在完成事务回滚之后，向协调者发送 ACK 消息。</p>
</li>
<li><p>中断事务</p>
<p> 协调者接收到所有参与者反馈的 ACK 消息后，完成事务中断。</p>
</li>
</ol>
<p>简单来说，二阶段提交将一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看作一个强一致性的算法。</p>
<h3 id="2PC-的优缺点"><a href="#2PC-的优缺点" class="headerlink" title="2PC 的优缺点"></a>2PC 的优缺点</h3><p>优点： 原理简单，实现方便</p>
<p>缺点：</p>
<ol>
<li><p>同步阻塞</p>
<p> 在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态。</p>
</li>
<li><p>单点问题</p>
<p> 一旦协调者出现问题，那么整个二阶段提交流程将无法运，其他参与者将会一直处于锁定事务资源的状态中。</p>
</li>
<li><p>数据不一致性</p>
<p> 当发生局部网络异常或者是协调者在尚未发生完 Commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求，于是，就只有部分参与者会进行事务的提交。</p>
</li>
<li><p>太过保守</p>
<p> 没有完善的容错机制，任意几个节点的失败都会导致整个事务的失败。</p>
</li>
</ol>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>3PC 将 2PC 的“提交事务请求”过程一分为二，形成了CanCommit、PreCommit和do Commit 三个阶段组成的事务处理协议</p>
<h4 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h4><ol>
<li><p>事务询问</p>
<p> 协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应</p>
<p> 参与者在接收到来自协调者的 canCommit 请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈 Yes，并且进入预备状态；否则，反馈No。</p>
</li>
</ol>
<h4 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h4><p>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作、正常情况下，包含两种可能。</p>
<p><strong>执行事务预提交</strong></p>
<p>假如协调者从所有的参与者获得的反馈都是 Yes，那么会进入预提交。</p>
<ol>
<li><p>发送预提交请求</p>
</li>
<li><p>事务预提交</p>
<p> 参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo信息记录到事务日志中</p>
</li>
<li><p>各参与者向协调者反馈事务执行的响应</p>
<p> 如果参与者成功执行了事务操作，那么就会反馈给协调者 ACK 响应，同时等待最终的指令：提交或终止</p>
</li>
</ol>
<p><strong>中断事务</strong></p>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li><p>发送中断请求</p>
<p> 协调者向所有参与者节点发出了 abort 请求。</p>
</li>
<li>中断事务</li>
</ol>
<h4 id="阶段三：doCommit"><a href="#阶段三：doCommit" class="headerlink" title="阶段三：doCommit"></a>阶段三：doCommit</h4><p>该阶段真正实现事务提交，会存在以下两种情况：</p>
<p><strong>执行提交</strong></p>
<ol>
<li><p>发送提交请求</p>
<p> 进入这一阶段，假设协调者处于正常工作状态，并且它接收了来自索引参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送 doCommit 请求。</p>
</li>
<li><p>事务提交</p>
<p> 参与者收到 doCommit 请求之后，会正式执行事务提交操作，完成后释放资源。</p>
</li>
<li><p>反馈事务提交结果</p>
<p> 参与者在完成事务提交操作之后，向协调者发送 ACK 消息。</p>
</li>
<li>完成事务</li>
</ol>
<p><strong>中断事务</strong></p>
<p>进入这一阶段，假设协调者处于正常工作状态，并且任一参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者无法收到所有参与者的反馈响应</p>
<ol>
<li><p>发送中断请求</p>
</li>
<li><p>事务回滚</p>
<p> 参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</p>
</li>
<li><p>反馈事务回滚结果</p>
<p> 参与者在完成事务回滚之后，向协调者发送 ACK 消息。</p>
</li>
<li><p>中断事务</p>
</li>
</ol>
<p>需要注意的是，一旦进入阶段三，会出现2个问题：</p>
<ul>
<li>协调者出现问题</li>
<li>协调者和参与者之间网络出现故障</li>
</ul>
<p>这两种情况会导致参与者无法及时接收到协调者发来的消息。针对这种情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<h3 id="3PC-的优缺点"><a href="#3PC-的优缺点" class="headerlink" title="3PC 的优缺点"></a>3PC 的优缺点</h3><p>相比 2PC，3PC 降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。但是，3PC 在参与者接收到 preCommit 消息后，如果出现网络分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然会出现数据不一致的情况。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/Java集合学习：HashMap实现原理/" itemprop="url">
                  Java集合学习：HashMap实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-24T14:33:21+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/24/Java集合学习：HashMap实现原理/" class="leancloud_visitors" data-flag-title="Java集合学习：HashMap实现原理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3><p>HashMap 是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值 和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>Hashmap 不是同步的，如果多个线程同时访问一个 HashMap，而其中至少一个线程从结构上（指添加或者删除一个或多个映射关系的任何操作）修改了，则必须保持外部同步，以防止对映射进行意外的非同步访问。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新键一个 HashMap 的时候，就会初始化一个数组。下面看下HashMap的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里有一个新键 entry 的过程：</p>
<pre><code class="java">table = <span class="keyword">new</span> Entry[capacity];
</code></pre>
<p>那什么是entry呢，我们看下 Entry 的源码实现：</p>
<pre><code class="java"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    <span class="keyword">final</span> <span class="keyword">int</span> hash;
    ……
}
</code></pre>
<p>我们目前还是只着重核心的部分，Entry 是一个 static class，其中包含了 key 和 value，也就是键值对，另外还包含了一个 next 的 Entry 指针。我们可以总结出：Entry 就是数组中的元素，每个 Entry 其实就是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h3 id="HashMap-的核心方法解读"><a href="#HashMap-的核心方法解读" class="headerlink" title="HashMap 的核心方法解读"></a>HashMap 的核心方法解读</h3><pre><code>/**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
public V put(K key, V value) {
        //其允许存放null的key和null的value，当其key为null时，调用putForNullKey方法，放入到table[0]的这个位置
        if (key == null)
            return putForNullKey(value);
        //通过调用hash方法对key进行哈希，得到哈希之后的数值。该方法实现可以通过看源码，其目的是为了尽可能的让键值对可以分不到不同的桶中
        int hash = hash(key);
        //根据上一步骤中求出的hash得到在数组中是索引i
        int i = indexFor(hash, table.length);
        //如果i处的Entry不为null，则通过其next指针不断遍历e元素的下一个元素。
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;
        addEntry(hash, key, value, i);
        return null;
}
</code></pre><p>我们看一下方法的标准注释：在注释中首先提到了，当我们 put 的时候，如果 key 存在了，那么新的 value 会代替旧的 value，并且如果 key 存在的情况下，该方法返回的是旧的 value，如果 key 不存在，那么返回 null。</p>
<p>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>addEntry(hash, key, value, i)方法根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：</p>
<pre><code>/**
     * Adds a new entry with the specified key, value and hash code to
     * the specified bucket.  It is the responsibility of this
     * method to resize the table if appropriate.
     *
     * Subclass overrides this to alter the behavior of put method.
     */
void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
}
void createEntry(int hash, K key, V value, int bucketIndex) {
        // 获取指定 bucketIndex 索引处的 Entry
        Entry&lt;K,V&gt; e = table[bucketIndex];
        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entr
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
        size++;
}
</code></pre><p>当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。</p>
<pre><code>final int hash(Object k) {
        int h = 0;
        if (useAltHashing) {
            if (k instanceof String) {
                return sun.misc.Hashing.stringHash32((String) k);
            }
            h = hashSeed;
        }
        //得到k的hashcode值
        h ^= k.hashCode();
        //进行计算
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre><p>我们可以看到在 HashMap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在 HashMap 中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<pre><code>/**
     * Returns index for hash code h.
     */
static int indexFor(int h, int length) {  
    return h &amp; (length-1);
}
</code></pre><p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。在 HashMap 构造器中有如下代码：</p>
<pre><code>// Find a power of 2 &gt;= initialCapacity
int capacity = 1;
while (capacity &lt; initialCapacity)  
    // capacity = capacity &lt;&lt; 1
    capacity &lt;&lt;= 1; 
</code></pre><p>这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。</p>
<p>当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>
<p>假设数组长度分别为 15 和 16，优化后的 hash 码分别为 8 和 9，那么 &amp; 运算后的结果如下：</p>
<table>
<thead>
<tr>
<th>h &amp; (table.length-1)</th>
<th>hash</th>
<th></th>
<th>table.length-1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>8 &amp; (15 - 1)</td>
<td>0100</td>
<td>&amp;</td>
<td>1110</td>
<td>= 0100</td>
</tr>
<tr>
<td>9 &amp; (15 - 1)</td>
<td>0101</td>
<td>&amp;</td>
<td>1110</td>
<td>= 0100</td>
</tr>
<tr>
<td>8 &amp; (16 - 1)</td>
<td>0100</td>
<td>&amp;</td>
<td>1111</td>
<td>= 0100</td>
</tr>
<tr>
<td>8 &amp; (16 - 1)</td>
<td>0101</td>
<td>&amp;</td>
<td>1111</td>
<td>= 0101</td>
</tr>
</tbody>
</table>
<p>从上面的例子中可以看出：当它们和 15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8 和 9 会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为 15 的时候，hash 值会与 15-1（1110）进行“与”，那么最后一位永远是 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1 得到的二进制数的每个位上的值都为 1，这使得在低位上&amp;时，得到的和原 hash 的低位相同，加之 hash(int h)方法对 key 的 hashCode 的进一步优化，加入了高位计算，就使得只有相同的 hash 值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，当数组长度为 2 的 n 次幂的时候，不同的 key 算得得 index 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre><code>/**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise
     * it returns {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it&apos;s also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }
    final Entry&lt;K,V&gt; getEntry(Object key) {
        int hash = (key == null) ? 0 : hash(key);
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }
</code></pre><p>有了上面存储时的 hash 算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从 HashMap 中 get 元素时，首先计算 key 的 hashCode，找到数组中对应位置的某一元素，然后通过 key 的 equals 方法在对应位置的链表中找到需要的元素。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据 hash 算法来决定其在数组中的存储位置，在根据 equals 方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry 时，也会根据 hash 算法找到其在数组中的存储位置，再根据 equals 方法从该位置上的链表中取出该Entry。</p>
<p>HashMap 的 resize（rehash）<br>当 HashMap 中的元素越来越多的时候，hash 冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap 的数组进行扩容，数组扩容这个操作也会出现在 ArrayList 中，这是一个常用的操作，而在 HashMap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize。</p>
<p>那么 HashMap 什么时候进行扩容呢？当 HashMap 中的元素个数超过数组大小 *loadFactor时，就会进行数组扩容，loadFactor的默认值为 0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为 16，那么当 HashMap 中元素个数超过 16*0.75=12 的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效的提高 HashMap 的性能。</p>
<h3 id="HashMap-的性能参数"><a href="#HashMap-的性能参数" class="headerlink" title="HashMap 的性能参数"></a>HashMap 的性能参数</h3><p>HashMap 包含如下几个构造器：</p>
<ul>
<li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
</ul>
<p>HashMap 的基础构造器 HashMap(int initialCapacity, float loadFactor) 带有两个参数，它们是初始容量 initialCapacity 和负载因子 loadFactor。</p>
<p>负载因子 loadFactor 衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</p>
<p>HashMap 的实现中，通过 threshold 字段来判断 HashMap 的最大容量：</p>
<pre><code>threshold = (int)(capacity * loadFactor);
</code></pre><p>结合负载因子的定义公式可知，threshold 就是在此 loadFactor 和 capacity 对应下允许的最大元素数目，超过这个数目就重新 resize，以降低实际的负载因子。默认的的负载因子 0.75 是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize 后的 HashMap 容量是容量的两倍：</p>
<h3 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>我们知道 java.util.HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p>
<p>ail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p>
<p>例如：当某一个线程 A 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。</p>
<p>这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对 HashMap 内容（当然不仅仅是 HashMap 才会有，其他例如 ArrayList 也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有 modCount++ 这句），那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。</p>
<pre><code>HashIterator() {
    expectedModCount = modCount;
    if (size &gt; 0) { // advance to first entry
    Entry[] t = table;
    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  
        ;
    }
}
</code></pre><p>在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：</p>
<p>注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p>
<pre><code>final Entry&lt;K,V&gt; nextEntry() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
</code></pre><p>在 HashMap 的 API 中指出：</p>
<p>由所有 HashMap 类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在上文中也提到，fail-fast 机制，是一种错误检测机制。它只能被用来检测错误，因为 JDK 并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<h4 id="HashMap-的两种遍历方式"><a href="#HashMap-的两种遍历方式" class="headerlink" title="HashMap 的两种遍历方式"></a>HashMap 的两种遍历方式</h4><p><strong>第一种</strong></p>
<pre><code>　　Map map = new HashMap();
　　Iterator iter = map.entrySet().iterator();
　　while (iter.hasNext()) {
　　Map.Entry entry = (Map.Entry) iter.next();
　　Object key = entry.getKey();
　　Object val = entry.getValue();
　　}
　　
</code></pre><p>效率高</p>
<p><strong>第二种</strong></p>
<pre><code>　　Map map = new HashMap();
　　Iterator iter = map.keySet().iterator();
　　while (iter.hasNext()) {
　　Object key = iter.next();
　　Object val = map.get(key);
　　}
　　
</code></pre><p>效率低</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="external">HashMap 的实现原理</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/23/分布式系统学习-事务处理与数据一致性/" itemprop="url">
                  分布式系统学习: 事务处理与数据一致性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-23T19:21:47+08:00" content="2016-10-23">
              2016-10-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/23/分布式系统学习-事务处理与数据一致性/" class="leancloud_visitors" data-flag-title="分布式系统学习: 事务处理与数据一致性">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务 (Transaction) 是由一些列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元 (Unit)，狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍然保持数据一致性的方法。</p>
<p>事务具有四个特征，分别是原子性、一致性，隔离性和持久性。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p>
<ul>
<li>全部执行成功</li>
<li>全部不执行</li>
</ul>
<p>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。即，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一半已经写入物理数据库，这时数据库就处于一种不正确的状态，或者是不一致的状态。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务的隔离性是指在并发环境中、并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。</p>
<p>在标准 SQL 规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，如未授权读取、授权读取、可重复读取和串行化。</p>
<p><strong>未授权读取</strong></p>
<p>未授权读取也被称为读未提交，该隔离级别允许脏读取，其隔离级别最低。比如，事务 A 和 事务 B 同时进行，事务 A 在整个执行阶段，会将某数据项的值从 1 开始，做一些列加法操作直到变成 10 之后进行事务提交，此时，事务 B 能够看到这个数据项在事务 A 操作过程中的所有中间值（如 1 变成 2、2 变成 3等），而对这一系列的中间值的读取就是未授权读取。</p>
<p><strong>授权读取</strong></p>
<p>授权读取也叫读已提交，它和未授权读取很像，唯一的区别就是授权读取只允许获取已经被提交的数据。以上面那个为例，事务 A 和 事务 B 同时进行，事务 A 进行与上述同样的操作，此时，事务 B 无法看到这个数据项在事务 A 操作过程中的所有中间值，只看到最终的 10。另外，如果说有一个事务 C，和事务 A 进行非常类似的操作，只是事务 C 是将数据项从 10 加到 20，此时事务 B 也同样可以读取到 20，即授权读取允许不可重复读取。</p>
<p><strong>可重复读取</strong></p>
<p>可重复读取，就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止了不可重复读取和脏读取，但是有可能出现幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。以上面为例，事务 B 第一次事务操作的过程中，始终对数据项读取到 1，但是在下一次事务操作中，即使事务 B 采用同样的查询方式，就可能会读取到10 或 20。</p>
<p><strong>串行化</strong></p>
<p>串行化是最严格的事务隔离级别。它要求所有事务都被串行执行，即事务只能一个接一个地进行处理，不能并发执行。</p>
<p>事务隔离级别越高，就越能保证数据的完整性和一致性，但同时对并发性能的影响也越大。通常，对绝大多数的应用程序来说，可以优先考虑将数据库系统的隔离级别设置为授权读取，这能够在避免脏读取的同时保证较好的并发性能。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态的变更就应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>在单机数据库中，我们很容易就能够实现一套满足 ACID 特性的事务处理系统，但在分布式数据库中，时间分散在各台不同的机器上，如何对这些数据进行分布式的事务处理具有非常大的挑战。</p>
<p>我们可以设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款服务，这两个服务本身是无状态并且是互相独立的，共同构成一个完整的分布式事务。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款前的状态，否则用户可能会发现自己的钱不翼而飞了。</p>
<h3 id="CAP-和-BASE-理论"><a href="#CAP-和-BASE-理论" class="headerlink" title="CAP 和 BASE 理论"></a>CAP 和 BASE 理论</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p>CAP 理论告诉我们，一个人分布式系统不可能同时满足一致性 (C：Consistency)、可用性(A：Availability)和分区容错性(P：Partition tolerance)这三个基本需求，最多同时满足其中的两项。</p>
<p><strong>一致性</strong></p>
<p>在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下更新操作后，应该保证系统的数据仍然处于一致的状态。</p>
<p><strong>可用性</strong></p>
<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每个操作请求总是能够在有限的时间内返回结果。这里我们重点看下“有限的时间内”和“返回结果”。</p>
<p>“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。</p>
<p><strong>分区容错性</strong></p>
<p>分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<p>网络分区是指在分布式系统中，不同的结点分布在不同的子网络中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p>
<h4 id="CAP-定理应用"><a href="#CAP-定理应用" class="headerlink" title="CAP 定理应用"></a>CAP 定理应用</h4><table>
<thead>
<tr>
<th>放弃CAP定理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>放弃P</td>
<td>如果希望能够避免系统出现分区容错性问题，一种较为简单的做法是将所有的数据（或者仅仅是那些与事务相关的数据）都放在一个分布式结点上。这样的做法虽然无法100%保证系统不会出错，但至少不会碰到由于网络分区带来的负面影响。但这样也放弃了系统的可扩展性</td>
</tr>
<tr>
<td>放弃A</td>
<td>相对于放弃“分区容错性”来说，放弃可用性则正好相反，其做法是一旦系统遇到网络分区或其他故障时，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用</td>
</tr>
<tr>
<td>放弃C</td>
<td>这里是放弃数据的强一致性。这样的系统无法保证数据实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。</td>
</tr>
</tbody>
</table>
<p>需要明确说明的是，对于一个分布式系统而言，分区容错性是一个最基本的要求。</p>
<h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h4><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写。</p>
<p>BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>基本可用</strong></p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，如</p>
<ul>
<li>响应时间上的损失</li>
</ul>
<p>正常情况下，一个在线搜索引擎在0.5秒之内返回查询结果，但由于出现故障，查询结果变为2秒</p>
<ul>
<li>功能上的损失</li>
</ul>
<p>正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利的完成每一笔订单，但是在高峰的时候，由于购物行为激增，部分消费者可能会被引导到一个降级页面。</p>
<p><strong>弱状态</strong></p>
<p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在的中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>在实际的工程实践中，最终一致性存在以下五类主要变种：</p>
<ul>
<li>因果一致性</li>
</ul>
<p>因果一致性是指，如果进程 A 在更新完某个数据项后通知了进程 B，那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值，即不能发生丢失更新情况。但与进程 A 无因果关系的进程 C 的数据访问则没有这样的限制。</p>
<ul>
<li>读已之所写</li>
</ul>
<p>读已之所写是指，进程 A 更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者来说，其读取到的数据，一定不会比自己上次写入的值旧。</p>
<ul>
<li>会话一致性</li>
</ul>
<p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读已之所写”的一致性，即，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<ul>
<li>单调读一致性</li>
</ul>
<p>单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对该进程后续的任何数据访问都不应该返回更旧的值。</p>
<ul>
<li>单调写一致性</li>
</ul>
<p>单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，最终一致性并不是只有那些大型分布式系统才涉及的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多数都会采用同步和异步方式来实现主备数据复制技术。在同步方式中，数据的复制通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长短，如果时间过长，那么显然，会出现数据不一致的情况，所以，这里就会用到最终一致性模型。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/22/数据库系统实现-索引结构小结/" itemprop="url">
                  数据库系统实现: 索引结构小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-22T15:22:02+08:00" content="2016-10-22">
              2016-10-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/22/数据库系统实现-索引结构小结/" class="leancloud_visitors" data-flag-title="数据库系统实现: 索引结构小结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>顺序文件</strong>：几种简单的文件组织，其产生方式是将数据文件按某个排序键排序并在该文件上建立索引。</p>
<p><strong>稠密索引和稀疏索引</strong>：稠密索引为数据文件的每个记录设一个键 - 指针对，而稀疏索引为数据文件的每个存储块设一个键 - 指针对。</p>
<p><strong>多级索引</strong>：在索引文件上再建立索引，在索引的索引上再建索引……这在有时候是很有用的。高级索引必须是稀疏的。</p>
<p><strong>辅助索引</strong>：即使数据文件没有按查找键 K 排序，我们也可以在键 K 上建立索引。这样的索引必须是稠密的。</p>
<p><strong>倒排索引</strong>：文件及其包含的词之间的关系通常可通过一个词 - 指针对的索引结构来表示。指针指向“桶”文件的某个位置，该位置上有一个指向文件中该词出现的地方的指针列表。</p>
<p><strong>B - 树</strong>：这些结构实质上是有着很好的扩充性能的多级索引。带有 N 个键和 N + 1 个指针的存储块被组织成一棵树。叶结点指向记录。任何时候所有非根索引块都在半满与全满之间。</p>
<p><strong>散列表</strong>：同我们创建主存散列表一样，我们也可以基于辅存的存储块来建立散列表。散列函数将键值映射到桶，有效地将数据文件的记录分配到多个小组（桶）。桶用一个存储块和可能出现的溢出块表示。</p>
<p><strong>可扩展散列</strong>：这种方法允许在存在记录数太多的桶时将桶的数目加倍。它使用指向块的指针数组来表示同。为了避免块过多，几个桶可以用同一个块表示。</p>
<p><strong>线性散列</strong>：这种方法每当桶中的记录比例超出阈值时增加一个桶。由于单个桶的记录不会引起表的扩展，所以在某些情形下需要溢出块。</p>
<p><strong>需要多维索引的查询</strong>：在多维数据上需要被支持的查询种类有：部分匹配、范围查询、最近邻查询和 where-am-I(包含一个给定点的区域或区域集)查询。</p>
<p><strong>最近邻查询的执行</strong>：许多数据结构允许通过执行一个围绕给定点的范围查询来执行最近邻查询。要是在该范围内不存在点，则扩大这个范围。因为在矩形范围内找到了点并不排除在矩形外有更近点的可能性，所以我们必须小心。</p>
<p><strong>网格文件</strong>：网格文件在每一维上切分点空间。网格线间的距离可以不同，且每一维上的网格线也可以不同。只有数据分布得相当均匀，网格文件就能很好的支持范围查询、部分匹配查询和最近邻查询。</p>
<p><strong>分段散列表</strong>：分段散列函数从每一维上构造桶号的一些二进制位。它们支持部分匹配查询较好，且不依赖于数据的均匀分布。</p>
<p><strong>多键索引</strong>：一个简单的多维结构有一个根，根是某个属性的索引，它导入第二个属性上的索引集合，而第二个属性的索引又导入第三个属性的索引集合等等。它们对于范围和最近邻查询有用。</p>
<p><strong>kd - 树</strong>：kd - 树像二叉搜索树，但它们按不同层次在不同属性上分支。它们较好地支持部分匹配、范围和最近邻查询。为了使该结构适合二维辅存操作，需要把多个树结点压缩到一个块。</p>
<p><strong>四叉树</strong>：四叉树划分多维立方体成四个象限，且若它们有太多的点，则递归地用同样的方式划分这些象限。它们支持部分匹配、范围和最近邻查询。</p>
<p><strong>R - 树</strong>：这种树的结构通常表示成区域的集合，且通过聚集它们成一个更大区域的层次结构。它对 where-am-I 查询有帮助。</p>
<p><strong>位图索引</strong>：这种索引结构支持多维查询。它排序点或记录并且通过位向量表示记录的位置。这些索引支持范围、最近邻和部分匹配查询。</p>
<p><strong>压缩位图</strong>：为了节省由很少个 1 的向量组成位的图索引的空间，通过采用分段长度编码来对位图索引进行压缩。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/22/Hash-Heap详解/" itemprop="url">
                  Hash Heap详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-22T10:08:22+08:00" content="2016-10-22">
              2016-10-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/22/Hash-Heap详解/" class="leancloud_visitors" data-flag-title="Hash Heap详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="性质和性质"><a href="#性质和性质" class="headerlink" title="性质和性质"></a>性质和性质</h3><p>和传统的 Hash 所不同的是，<strong>HashHeap</strong> 在查询这一块优化了，原有的方法将 <strong>Heap</strong> 存放到数组中，遍历数组查询某个数的时间复杂度为 o(n)，而选用 <strong>Hash</strong> 来存放原来 <strong>Heap</strong> 中的每个元素时，查询的辅助马上降为 o(1)。</p>
<h3 id="接口和时间复杂度分析"><a href="#接口和时间复杂度分析" class="headerlink" title="接口和时间复杂度分析"></a>接口和时间复杂度分析</h3><pre><code>插入 o(logn)
1. add(self, key, value)

删除 o(logn)
2. remove(self, key)

查找 o(log1)
3. hasKey(self, key)

取最大值 o(log1)
4. max(self)
</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class HashHeap:
    def __init__(self):
        self.heap = [0]
        self.hash = {}

def add(self, key, value):
    self.heap.append((key, value))
    self.hash[key] = self.heap[0] + 1
    self.heap[0] += 1
    self._siftup(self.heap[0])

def remove(self, key):
    index = self.hash[key]
    self._swap(index, self.heap[0])
    del self.hash[self.heap[self.heap[0]][0]]
    self.heap.pop()
    self.heap[0] -= 1
    if index &lt;= self.heap[0]:
        index = self._siftup(index)
        self._siftdown(index)

def hasKey(self, key):
    return key in self.hash

def max(self):
    return 0 if self.heap[0] == 0 else self.heap[1][1]

def _swap(self, a, b):
    self.heap[a], self.heap[b] = self.heap[b], self.heap[a]
    self.hash[self.heap[a][0]] = a
    self.hash[self.heap[b][0]] = b

def _siftup(self, index):
    while index != 1:
        if self.heap[index][1] &lt;= self.heap[index / 2][1]:
            break
        self._swap(index, index / 2)
        index /= 2
    return index

def _siftdown(self, index):
    size = self.heap[0]
    while index &lt; size:
        t = index
        if index * 2 &lt;= size and self.heap[t][1] &lt; self.heap[index * 2][1]:
            t = index * 2
        if index * 2 + 1 &lt;= size and self.heap[t][1] &lt; self.heap[index * 2 + 1][1]:
            t = index * 2 + 1
        if t == index:
            break
        self._swap(index, t)
        index = t
    return index
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/22/数据库系统实现-位图索引/" itemprop="url">
                  数据库系统实现: 位图索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-22T08:12:57+08:00" content="2016-10-22">
              2016-10-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/22/数据库系统实现-位图索引/" class="leancloud_visitors" data-flag-title="数据库系统实现: 位图索引">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是位图索引？"><a href="#什么是位图索引？" class="headerlink" title="什么是位图索引？"></a>什么是位图索引？</h3><p>我们先设想文件的记录有一个永久的编号：1，2，…，n。此外，文件存在某种数据结构，它对于任意的一个 i 可使我们容易地找到第 i 个记录。字段 F 的<em>位图索引</em>是有个长度为n的位向量的集合。每一个位向量对应于字段F中可能出现的一个值。如果第 i 个记录的字段F的值为 v，那么对应于值 v 的位向量在位置 i 上的取值为1；否则该向量的位置 i 上的取值为0。</p>
<p>下面举个例子，</p>
<p>假设一个文件中的记录由两个字段 F 和 G 组成，分别为整数型和字符串型。目前文件中有 6 个记录，编号为 1 到 6，它们的值以此如下：(30, foo), (30, bar), (40, baz), (50, foo), (40, bar), (30, baz)。</p>
<p>第一个字段 F 的位图索引有 3 个位向量，每个长度为 6。第一个对应于30，是110001，因为第一、第二和第六个记录都是 F = 30；另外两个分别对应于 40 和 50，是 001010 和 000100。</p>
<p>字段 G 的位图索引也有 3 个位向量，因为那儿有 3 个不同的字符串出现。3 个向量是:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>向量</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>100100</td>
</tr>
<tr>
<td>bar</td>
<td>010010</td>
</tr>
<tr>
<td>baz</td>
<td>001001</td>
</tr>
</tbody>
</table>
<p>在每种情形下，1 表示在那个记录中出现了相应的字符串。</p>
<h3 id="位图索引的动机"><a href="#位图索引的动机" class="headerlink" title="位图索引的动机"></a>位图索引的动机</h3><p>初看，位图索引需要太多的空间，尤其是当字段有许多不同值时，因为位的总数是记录和取值数的乘积。例如，如果字段是键，且记录数为 n，那么该字段的所有位向量需要使用 n^2 个二进制位。不过，压缩能够使位的数量接近于n，而与不同字段值的数量无关。</p>
<p>位图索引的补偿优势是它们允许我们在许多情形下高效地回答部分匹配查询。在某种意义上来说，它具备类似桶的优势。</p>
<p>位图索引能够帮助回答范围查询。它用一些短的位向量详细地显示了位向量的逐位与/或如何能够被用来找到查询的答案，它只查找我们所要的记录而不会查找任何其他记录。</p>
<p>下面来看，</p>
<p><img src="/img/3.41.png" alt=""></p>
<p>对第一个分量年龄，它有 7 个不同值，因此年龄的位图索引由下面 7 个向量组成：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>25: 100000001000</td>
<td>30: 000000010000</td>
<td>45: 010000000100</td>
</tr>
<tr>
<td>50: 001110000010</td>
<td>60: 000000000001</td>
<td>70: 000001000000</td>
</tr>
<tr>
<td>85: 000000100000</td>
<td></td>
</tr>
</tbody>
</table>
<p>对于薪水分量，它有10个不同值，因而薪水的位图索引有下面10个分量：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>60: 110000000000</td>
<td>75: 001000000000</td>
<td>100: 000100000000</td>
</tr>
<tr>
<td>110: 000001000000</td>
<td>120: 000010000000</td>
<td>140: 000000100000</td>
</tr>
<tr>
<td>260: 000000010001</td>
<td>275: 000000000010</td>
<td>350: 000000000100</td>
</tr>
<tr>
<td>400: 000000001000</td>
<td></td>
</tr>
</tbody>
</table>
<p>假定我们要找出年龄范围在 45 ~ 55且薪水范围在100 ~ 200的所有首饰购买者。我们先找出在这个范围内的年龄值向量。 我们先找出在这个范围内的年龄值向量，如果将它们按位取或，我们就得到一个新向量：当且仅当第 i 个记录的年龄在给定范围内时它的位置 i 上取值为 1，且该向量为 01110000110。</p>
<p>下一步，我们找出范围在 100K 到 200K 之间的薪水值向量：它们有 4 个，分别对应于薪水100、110、120和140，它们的按位或结果是000111100000。</p>
<p>最后一步是取我们通过“或”运算得到的两个位向量的按位与，即：</p>
<pre><code>011110000110 AND 000111100000 = 000110000000
</code></pre><p>于是我们找到只有第4和第5个记录(50, 100)和(50，120)是在所要求的范围内。</p>
<h3 id="压缩位图"><a href="#压缩位图" class="headerlink" title="压缩位图"></a>压缩位图</h3><p>假定我们在一个有 n 个记录的文件的字段F上建有位图索引，且在文件中出现的字段 F 的不同值的数目为 m。那么该索引的所有位向量的二进制位数就是 mn。如果说块的大小为 4096 个字节，那么在一个块中我们可存放32768位，因此所需块数是 mn/32768。这个数比存放文件本身所需的块数要小，但是随着 m 的变大，位图索引所需空间也就越多。</p>
<p>但是如果 m 很大，那么位向量中的 1 将会很少。精确地说，任何一位出现 1 的概率为 1/m。如果 1 很少，那么我们就有机会编码位向量以便它们平均所占用的位比 n 少得多。一个常用的方法叫做<strong>分段长度编码</strong>，段是由 i 个 0 后跟一个 1 所组的序列，通过对整数 i 适当的二进制编码来表示一个段。我们把每个段的代码拼接在一起，则这个位序列就是整个位向量的编码。</p>
<p>我们的编码方法是，首先确定 i 的二进制表示是多少位，这个数字 j 近似地等于 log2i，被表示成“一元”: j - 1 个 1 和 一个 0。然后，我们在它后面加上 i 的二进制表示。</p>
<p>下面来举例：</p>
<pre><code>例1. 如果 i = 13， 那么 j = 4。即我们需要 4 位二进制来表示 i。因此，i 的编
码开始部分为 1110。我们把 i 的二进制数 1101 加上，这样，13的编码就是11101101。
</code></pre><p>i = 1的编码是 01，而 i = 0的编码是00。在这两种情况下，j = 1，因此我们以一个 0 开始且 0 后面为表示 i 的一位二进制数。</p>
<p>相似的我们也可以完成解码。</p>
<pre><code>例2. 让我们来对序列 11101101001011 进行解码。从头开始，
我们在第四位上找到第一0，因而 j = 4，下面四位为 1101，
因而我们确定第一个整数是13.现在我们剩下001011要解码。

由于第一位是0，我们知道下一位表示整数本身，该整数为0。
因此我们已经解码的序列为 13、0，而且我们必须解码剩下的序列 1011。

我们在第二个位置上找到第一个 0，于是我们下结论：最末两位表示最后的整数3。
我们整个分段长度序列是这样：13，0，3。
从这些数字，我们能够重新构造实际的位向量：0000000000000110001。
</code></pre><h3 id="位图索引的管理"><a href="#位图索引的管理" class="headerlink" title="位图索引的管理"></a>位图索引的管理</h3><h4 id="查找位向量"><a href="#查找位向量" class="headerlink" title="查找位向量"></a>查找位向量</h4><p>把位向量看成记录，它们的键时对应于该位向量的字段值（虽然值本身不在“记录”中出现）。然后任何辅助索引技术都可以使我们有效地按值找到它们的位向量。</p>
<p>我们也需要在某处存储位向量。最好是把它们看作可变长记录，因为随着数据文件中记录的增加，它们一般会增长。</p>
<h4 id="查找记录"><a href="#查找记录" class="headerlink" title="查找记录"></a>查找记录</h4><p>一旦我们确定了我们所需要的文件中的记录 k，那第 k 个记录看作索引键值为 k。然后我们可在数据文件上创建辅助索引，它的索引键时记录号。</p>
<h4 id="数据文件修改的处理"><a href="#数据文件修改的处理" class="headerlink" title="数据文件修改的处理"></a>数据文件修改的处理</h4><p>在位图索引中，要反映数据文件的修改有两方面问题：</p>
<ol>
<li>一旦分配后，记录数必须保持一定。</li>
<li>数据文件的改变需要位图索引也做相应改变。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/21/数据库系统实现-多维数据的树结构/" itemprop="url">
                  数据库系统实现: 多维数据的树结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-21T15:40:23+08:00" content="2016-10-21">
              2016-10-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/21/数据库系统实现-多维数据的树结构/" class="leancloud_visitors" data-flag-title="数据库系统实现: 多维数据的树结构">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>多维数据常用的几种树结构有：</p>
<ol>
<li>多建索引</li>
<li>kd - 树</li>
<li>四叉树</li>
<li>R - 树</li>
</ol>
<p>前三种用于点集。 R - 树通常用来表示区域的集合，它也可以用来表示点集合。</p>
<h3 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h3><p>假若我们有几个属性来表示我们的数据点的维，并且我们想在这些点上支持范围查询或最近邻查询。用来访问这些点的一个简单的树模式是索引的索引，即它的每一层的结点都是一个属性的索引。</p>
<p>在多键索引中，有些第二级或更高级索引可能会很小。因此把几个简单表压缩到一个块中来实现这些索引可能是合适的。</p>
<h3 id="多键索引的性能"><a href="#多键索引的性能" class="headerlink" title="多键索引的性能"></a>多键索引的性能</h3><p>我们这里考虑两种属性的情形。</p>
<h4 id="部分匹配查询"><a href="#部分匹配查询" class="headerlink" title="部分匹配查询"></a>部分匹配查询</h4><p>如果第一个属性被指定，那访问是很有效的。我们使用根索引找到一个子索引，该子索引引导我们到想要的点上。与此相反，如果第一个属性没有给出一个指定值，那我们必须搜索每一个子索引，潜在地这是一个耗时的处理过程。</p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>如果单个索引本身在它们各自的属性上支持范围查询—比如说，B - 树索引或者索引顺序文件，多键索引对范围查询就会运作得很好。为了回答一个范围查询，我们使用根索引和第一个属性的范围找出可能包含答案点的索引子索引。然后我们使用第二个属性的指定范围搜索每个子索引。</p>
<h4 id="最近邻查询"><a href="#最近邻查询" class="headerlink" title="最近邻查询"></a>最近邻查询</h4><p>这类查询可以通过一系列范围查询来完成。</p>
<h3 id="kd-树"><a href="#kd-树" class="headerlink" title="kd - 树"></a>kd - 树</h3><p>kd - 树 (k维搜索树) 是把二叉搜索树推广到多维数据的一种主存数据结构。我们将介绍这种思想，然后讨论怎样使这种思想适合存储的块模型。 kd - 树是一个二叉树，它的内部结点有一个相关联的属性 a 和一个值 V，它将数据点集划分成两个部分：a 值小于V的部分和a值大于等于V的部分。由于所有维的属性在层间交替出现，所以树的不同层上的属性是不同的。一个典型的 kd - 树如下图所示。</p>
<p><img src="/img/kdtree.png" alt=""> </p>
<p>在一般的 kd - 树中，数据点被存放在结点内，就像在二叉搜索树中一样。不过我们开始引入这个思想时做了两个修改，以便获得块模式的有限益处：</p>
<ol>
<li>内部结点只有一个属性，该属性的一个划分值和指向左、右子树的指针。</li>
<li>叶结点是块，块空间中存放着尽可能多的记录。</li>
</ol>
<h3 id="kd-树的操作"><a href="#kd-树的操作" class="headerlink" title="kd - 树的操作"></a>kd - 树的操作</h3><p>查找一个所有维都给定值的元组的处理如同在二叉树中一样。我们在每个内部结点上决定哪个走向并且被引向我们所需的单个叶结点的块。</p>
<p>为了实现一个插入，我们先做一个查找。最后我们找到一个叶结点，如果叶结点的块中还有空间，我们就把新的数据点放在那里；如果没有空间，我们把块分裂成两个，并根据分裂叶结点所在层的相应属性划分叶结点中的内容。最后，我们创建一个新的内部结点：它的子结点为分裂得到的两个新块，并且给该内部结点一个与分裂相对应的划分值。</p>
<p>下图展示了一个 kd - 树插入的例子：如果我们要插入一个年龄为35且薪水为500K的点</p>
<p><img src="/img/kdtree2.png" alt=""></p>
<h4 id="部分匹配查询-1"><a href="#部分匹配查询-1" class="headerlink" title="部分匹配查询"></a>部分匹配查询</h4><p>如果我们给定某些属性的值，那么当我们处于属性值已知的层的结点上时，我们可以往一个方向走；当我们处于属性值未知的结点上时，我们必须考察它的两个子结点。如果我们要找出图3-39的树中索引年龄为50的点，我们必须考察根的两个子结点，因为根是按薪水来分裂的。可是，在根的左子结点上，我们只需要往左走；在根的右子结点上，我们也只需考察它的右子树。假如，假定树是完全平衡的，索引有两维，如果只给定其中一维的值，那我们将不得不交替使用这两种方式来考察各层结点。(访问结点数)最终达到叶结点数的平方根。</p>
<h4 id="范围查询-1"><a href="#范围查询-1" class="headerlink" title="范围查询"></a>范围查询</h4><p>有时一个范围运行我们移动到结点的某个唯一的子结点，但如果范围跨越了结点的划分值，那我们就必须考察两个子结点。</p>
<h3 id="使-kd-树适合辅助存储器"><a href="#使-kd-树适合辅助存储器" class="headerlink" title="使 kd - 树适合辅助存储器"></a>使 kd - 树适合辅助存储器</h3><p>假定我们用一个有 n 个叶结点的 kd - 树存放文件，那么从根到叶结点的路径的平均长度将大约是log2n，如同任何二叉树一样。如果我们每块存放一个结点，那么当我们遍历一条路径时，我们必须为每个结点做一次磁盘 I/O。例如，如果n = 1000，那我们大约需要10次磁盘 I/O，远远超过通常 B -树的2到3次磁盘 I/O—即使是一个十分大的文件。另外，由于 kd - 树内部结点的信息相对地少，块的大部分空间将被浪费掉。下面的两种方法有助于解决长路径和未用空间这一孪生问题。</p>
<ol>
<li><p>内部结点的多分支。 kd - 树的内部结点里可以有多个键 -指针对，它看起来更像 B -树结点。如果我们在结点里有n个键，我们能够把属性a的值分裂成 n + 1个范围。如果有 n + 1个指针，我们能够沿着适当的指针到只包含属性 a 值的那个范围内的点的子树。</p>
</li>
<li><p>聚集内部结点到块。我们可以把多个内部结点压缩到一个块中。为了减少遍历路径访问的块数量，我们最好远离一个结点一个块的方式二将若干层的所有子结点存入一个块。在这种方式下，一旦我们检索到该结点的块，我们必定会使用该块中的其他某些结点，节省了磁盘I/O。</p>
</li>
</ol>
<h3 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h3><p>在一个四叉树中，每个内部结点对应于二维空间中的一个正方形区域，或是k维空间的k维立方体。像之前介绍的其他数据结构一样，我们主要考虑二维的情形。如果一个正方形中的点数不比一个块中能存放的数多，那么我们就把这个正方形看作树的叶结点，并且它由存放它的点的块表示；如果矩形中还有太多的点以至于一个块存放不下，那么把这个正方形看作内部结点，它的子结点对应于它的4个象限。</p>
<h3 id="R-树"><a href="#R-树" class="headerlink" title="R-树"></a>R-树</h3><p>R-树 (区域树) 是一种利用 B -树的某些本质特征来处理多维数据的数据结构。B - 树的结点有一个键的集合，这些键把线分成片段，沿着那条线的每个点仅属于一个片段，B - 树因此使我们很容易地找到点。如果我们把沿线各处的点表示成 B - 树结点，我们就能够确认定点所属的唯一子结点，在那里可以找到该点。</p>
<p>而R - 树表示由二维或更高维区域组成的数据，我们把它称为<em>数据区</em>。R - 树的一个内部结点对应于某个<em>内部区域</em>，或称“区域”，它不是普通的数据区。原则上，区域可以是任何形状，虽然实际上它经常为矩形或其他简单形状。R - 树的结点的键位置上含有子区域，它表示结点的子结点的内容。允许子区域有部分重叠，尽管我们希望重叠较小。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/20/数据库系统实现-散列表/" itemprop="url">
                  数据库系统实现: 散列表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-20T16:03:50+08:00" content="2016-10-20">
              2016-10-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/20/数据库系统实现-散列表/" class="leancloud_visitors" data-flag-title="数据库系统实现: 散列表">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有许多涉及散列表的数据结构可用作索引。假定一个<em>散列函数 h</em>， 它以查找键（散列键）为参数并计算出一个介于0到B-1的整数，其中B是桶的数目。桶数组，即一个序号从0到B-1的数组，其中包含B个链表的头，每一个对应于数组中的一个桶。如果记录的查找键为K，那么我们通过将该记录链接为<em>h(K)</em>的桶表中来存储它。</p>
<h3 id="辅助散列表"><a href="#辅助散列表" class="headerlink" title="辅助散列表"></a>辅助散列表</h3><p>有的散列表包含大量记录，以至于它们主要存放在辅助存储器上，这样的散列表在一些细小而重要的方面与主存中的散列表存在区别。首先，<strong>桶数组由存储块组成而不是由指向链表头的指针组成</strong>。通过散列函数 <em>h</em> 散列到某个桶中的记录被放到该桶的存储块中，如果桶中有太多的记录，那么可以给该桶加溢出块的链以存放更多的记录。</p>
<p>我们将假定，只要给一个 <em>i</em>，桶 <em>i</em> 的第一个存储块的位置就可以被找到。例如，主存中可以有一个指向存储块的指针数组，数组项以桶号为序号。另一种可能是把每个桶第一个存储块存放在磁盘上某固定的、连续的位置，这样我们就可以根据整数i计算出桶 <em>i</em> 的位置。</p>
<h3 id="散列表的插入"><a href="#散列表的插入" class="headerlink" title="散列表的插入"></a>散列表的插入</h3><p>当一个查找键为K的新纪录需要被插入时，我们计算<em>h(K)</em>。如果桶号为<em>h(K)</em>的桶还有空间，我们就把该记录放到此桶的存储块中或在其存储块没有空间时存储到块链上的某个溢出块中。如果桶的所有存储块都没有空间，我们就增加一个新的溢出块到该桶的链上，并把新记录存入该块。</p>
<h3 id="散列表的删除"><a href="#散列表的删除" class="headerlink" title="散列表的删除"></a>散列表的删除</h3><p>删除查找键值为K的记录与插入操作的方式相同。我们找到桶号为<em>h(K)</em>的桶且从中搜索查找键为K的记录，继而将找到的记录删除。如果我们可以将记录在块中移动，那么删除记录后，我们可选择合并同一链上的存储块。</p>
<h3 id="散列表索引的效率"><a href="#散列表索引的效率" class="headerlink" title="散列表索引的效率"></a>散列表索引的效率</h3><p>理想的情况是有足够的桶，绝大多数桶都只由单个块组成。如果这样，那么一般的查询只需一次磁盘I/O，且文件的插入和删除也只需两次磁盘I/O。这样的结果比直接用稀疏索引、稠密索引或<strong>B - 树</strong>好的多（尽管散列表不能像<strong>B - 树</strong>那样支持范围查询）</p>
<p>但是如果文件不断增长，那么最终就会出现一般的桶的链表中都有许多块的情况。如果这样，我们就需要在块的长链表中查找，每个块至少需要一次磁盘I/O。因此，我们就必须设法减少每个桶的块数。所要进而就要引入<strong>动态散列表</strong>，他们允许B改变，使B近似于记录总数除以块中能容纳的记录数所得到的商。即每个桶大约有一个存储块。</p>
<h3 id="可扩展散列表"><a href="#可扩展散列表" class="headerlink" title="可扩展散列表"></a>可扩展散列表</h3><p>可扩展散列表是动态散列表的一种，相比静态散列表，它主要增加了：</p>
<ol>
<li>为桶引入了一个间接层，即用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶。</li>
<li>指针数组能增长，它的长度总是2的幂，因而数组没增长一次，桶的数目就翻倍。</li>
<li>不过，并非每个桶都有一个数据块；如果某些桶中的所有记录可以放到一个块中，那么这些桶可能共享一个块。</li>
<li>散列函数<em>h</em>为每个键计算一个K位二进制序列，该K足够大，比如32。但是，桶的数目总是使用从序列第一位或最后一位算起的若干位，此位数小于K，比如说是第 <em>i</em> 位。也就是说，当 <em>i</em> 是使用的位数时，桶数组将有2的i次方个项。</li>
</ol>
<p>下图为一个小的可扩展散列表，</p>
<p><img src="/img/hash1.png" alt=""> </p>
<p>为简单起见，我们假设 K = 4，即散列函数 h 只产生4位二进制序列。当前使用的只有其中一位。正如桶上标记的，i = 1。因此桶数组只有2个项，一个对应 0，一个对应 1。</p>
<p>桶数组中的项指向两个块。第一块存放当前所有查找键被散列成以 0 开头的二进制序列的记录；第二个块存放所有查找键被散列成以 1 开头的二进制序列的记录。其中每个存储块的”小方块”中都出现了数字 1 ， 这个数字表明由散列函数得到的位序列中有多少位用于确定记录在该块中的成员资格。随着散列表的增长，不同块中需要考虑的位数可能不同。也就是说，桶数组的大小由我们正在使用的最大二进制位数来决定，但有些块可能使用较少的位数。</p>
<h3 id="可扩展散列表的插入"><a href="#可扩展散列表的插入" class="headerlink" title="可扩展散列表的插入"></a>可扩展散列表的插入</h3><p>可扩展散列表的插入开始时类似静态散列表的插入。为了插入键值为K的记录，我们计算出 <em>h(k)</em>，取出这一二进制位序列的前 <em>i</em> 位，并找到桶数组中序号为 <em>i</em> 的项。注意，因为 <em>i</em> 作为数据结构的一部分保存，我们能确定 <em>i</em>。</p>
<p>我们根据同数组中该项的指针找到某个存储块 B。如果B 中还有存放新记录的空间，我们就把心记录存入，而插入也就完成了。如果B 中没有空间，那么视数字 <em>j</em> 的不同有两种可能，数组 <em>j</em>表明散列值中有多少位用于确定存储块B的成员资格， <em>j</em>的值即那个在每个存储块的小方块中可以找到的那个值。</p>
<p>插入的步骤如下：</p>
<p>如果 j &lt; i，那么不必对桶数组做什么变化。我们：</p>
<p>a) 将块B分裂成两个存储块。</p>
<p>b) 根据记录散列值的第( j+1) 位，将B中记录分配到这两个存储块中，该位为 0 的记录保留在B中，而该位为 1 的记录则放入到新块中。</p>
<p>c) 把( j+1) 存入这两个存储块的小方块中，以表明用于确定成员资格的二进制位数字。</p>
<p>d) 调整桶数组中的指针，使原来指向块 B的项指向块B 或新块， 这由项的第( j+1)位决定。</p>
<p>如果  j = i，那么我们必须先将 i 加 1。我们使桶数组长度翻一倍，因此数组中现有2的( i+1)次方个项。假定 w 是以前的桶数组中作为某项序号的 i 位二进制位序列。在新桶数组中，序号为w0 和 w1的项都指向原 w 项指向的块。也就是，这2个新项共享一个存储块，而存储块本身没有变化。该块的存储资格仍然按原先的位数确定。最后，仍然按第一种情况来分裂B。</p>
<h3 id="线性散列表"><a href="#线性散列表" class="headerlink" title="线性散列表"></a>线性散列表</h3><p>可扩展散列表最大的好处在于当查找一个记录时，我们总是只需要查找一个数据块。我们还需要查找到一个桶数组的项，但如果桶数组小到可以存放在主存中，那么访问桶数组就不需要进行磁盘 I/O。然而，可扩展散列表也有一些缺点：</p>
<ol>
<li>当桶数组需要翻倍时，要做大量的工作。这些工作会阻碍对数据文件的访问，或是使某些插入看来花费很长的时间。</li>
<li>当桶数翻倍后，它在主存中可能就装不下了，或者把其他的一些我们需要保存在主存的数据挤出去。其结果是，一个运行良好的系统可能突然之间每个操作所需磁盘I/O开始大增。</li>
<li>如果每块的记录数很少，那么很有可能某一块的分裂比在逻辑上讲需要分裂的时间提前许多。例如，如果像我们使用的例子，块中可以存放2个记录，即使记录的总数远小于2的20次方，也有可能出现三个记录的前20位二进制位序列一样。在这种情况下，我们不得不使用 i = 20 和 100万个桶数组项，尽管存有记录的块数远小于100万。</li>
</ol>
<p>有一种线性散列的策略，桶的增长较为缓慢。它的特点主要有：</p>
<ul>
<li>桶数 n 的选择总是使存储块的平均记录数保持与存储块所能容纳的记录总数成一个固定的比例，如 80%。</li>
<li>由于存储块并不总是可以分裂，所以允许有溢出块，尽管每个桶的平均溢出块数远下于1。</li>
<li>用来作桶数组项序号的二进制位数是[log2n]，其中 n 是当前的桶数。这些位总是从散列函数得到的位序列的右(低位)端开始取。</li>
<li>假定散列函数值的 i 位正在用来给桶数组项编号，且有一个键值为 K 的记录想要插入到编号为a1a2….ai的桶中；即a1a2…ai是h(K)的后 i 位。那么，把 a1a2…ai 当作二进制整数，设它为m。如果 m &lt; n，那么编号为 m 的桶存在并把记录存入该桶中。如果 n &lt;= m &lt; 2^i，那么 m 桶还不存在，因此我们把记录存入桶 m - 2^i-1，也就是当把我们a1(它肯定是1)改为0时对应的桶。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/14/数据系统实现-B-树详解/" itemprop="url">
                  数据系统实现: B - 树详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-14T11:25:31+08:00" content="2016-10-14">
              2016-10-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/14/数据系统实现-B-树详解/" class="leancloud_visitors" data-flag-title="数据系统实现: B - 树详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然一级或两级索引通常有助于加快查询，但在商用系统中常使用一种更通用的结构。这一数据结构家族称为<strong>B - 树</strong>，而最常用的是其称为<strong>B + 树</strong>的变体。实质上：</p>
<ul>
<li>B - 树能自动地保存与数据文件大小相适应的索引层次。</li>
<li>对所使用的存储块空间进行管理，使每个块的充满程度在半满与全满之间。</li>
</ul>
<h3 id="B-树的结构"><a href="#B-树的结构" class="headerlink" title="B - 树的结构"></a>B - 树的结构</h3><p><strong>B - 树</strong>把它的存储块组织成一棵树。这棵树是<em>平凡的</em>，即从树根到树叶的所有路径都一样长。通常<strong>B - 树</strong>有三层：根、中间层和叶，但也可以是任意多层。为了对<strong>B - 树</strong>有一个直观的印象，我们可以参考下图。</p>
<p><img src="/img/btree.png" alt=""></p>
<p>对应于每个<strong>B - 树</strong>索引都有一个参数n，它决定了<strong>B - 树</strong>的所有存储块的布局。每个存储块的布局。每个存储块存放n个查找键值和n+1个指针。在某种意义上讲，<strong>B - 树</strong>的存储块类似索引块，只不过<strong>B - 树</strong>的块除了有n个键 - 指针对外，还有一个额外的指针。在存储块能容纳n个键和n+1个指针的前提下，我们尽可能把n取大。</p>
<p><strong>B - 树</strong>的每一个节点的构造如下图所示。</p>
<p><img src="/img/btree_node.png" alt=""></p>
<p>有几条重要的规则限制 <strong>B - 树</strong>的存储块中能出现的东西:</p>
<ul>
<li>叶结点中的键是数据文件中的键的拷贝，这些键以排好序的形式，从左到右分布在叶结点中。</li>
<li>根结点中至少有两个指针被使用。所有指针指向位于<strong>B - 树</strong>下一层的存储块。</li>
<li>叶结点中，最后一个指针指向它右边的下一个叶结点存储块，即指向下一个键值大于它的块。在叶块的其他n个指针当中，至少有 (n+1) / 2 (往下取余）指针被使用且指向数据记录；未使用的指针可看作空指针且不指向任何地方。如果第i个指针被使用，则指向具有第i个键值的记录。</li>
<li>在内层结点中，所有的n+1个指针都可以用来指向<strong>B - 树</strong>中下一层的块。它们中至少 (n + 1) / 2 (往上取余）个指针真正使用（但如果是根结点，则不管n多大都只要求至少两个指针被使用）。如果j个指针被使用，那该块中将有 j - 1 个键，设为K1，K2，…，Kj-1。第一个指针指向<strong>B - 树</strong>的一部分，所有键值等于K1且小于K2的记录可在这一部分中…。依此类推。最后，第j个指针指向<strong>B - 树</strong>的又一部分，一些键值大于Kj-1的记录可以在这一部分找到。某些键值远小于K1或远大于Kj-1的记录可能根本无法通过该块到达，但可通过同一层的其他块到达。</li>
<li>所有被使用的键和指针通常都存放在数据块的开头位置，叶结点第 (n+1) 个指针是个例外，它指向下一个叶结点。</li>
</ul>
<h3 id="B-树的应用"><a href="#B-树的应用" class="headerlink" title="B - 树的应用"></a>B - 树的应用</h3><p><strong>B - 树</strong>是用来建立索引的一种强有力的工具。它的叶结点上指向记录的一些列指针可以起到索引文件的作用。下面介绍一些实例：</p>
<ol>
<li><img src="/img/btree_node.png" alt="">的查找键时数据文件的主键，且索引是稠密的。也就是说，叶结点中为数据文件的每一个记录设有一个键 - 指针对。该数据文件可以按主键排序，也可以不按主键排序。</li>
<li>数据文件按主键排序，且<strong>B + 树</strong>是稀疏索引，在叶结点中为数据文件的每个块设有一个键 -指针对。</li>
<li>数据文件按非键属性排序，且该属性是<strong>B + 树</strong>的查找键。叶结点中为数据文件里出现的每个属性值K设有一个键 -指针对，其中指针指向排序键值为K的记录中的第一个。</li>
</ol>
<p><strong>B - 树</strong>变种的另一些应用允许叶结点中查找键重复出现。如下图所示。</p>
<p><img src="/img/btree2.png" alt=""></p>
<p>与之前不同是，现在，假定一个内部结点的键为K1、K2，…，Kn，那么 Ki 将会是从第 i+ 1 个指针所能访问的子树种出现的最小新键。这里的“新”，我们是指在树中第 i + 1 个指针所指向的子树<strong>以左</strong>没有出现过 Ki，但 Ki 在第 i + 1 个指针指向的子树种至少出现一次。某些情况下可能不存在这样的键，这时 Ki 可以为空，但它对应的指针仍然需要，因为它指向树中碰巧只有一个键值的那个重要的部分。</p>
<p>在上图所示的<strong>B - 树</strong>中，</p>
<ul>
<li>查找13时，我们不会到达根结点的第二个子结点，而是直接到第一个子结点中去查找</li>
<li>如果我们查找介于24和36之间的某个键，我们会直接到第三个叶结点中查找。但当我们连一个所需键值都找不到时，我们就知道不必继续往右查找。举个例子，如果叶结点中存在键24，它要么在第四个叶结点上，这时根据根结点的第二个子结点中的空键将会被24替代；要么在第五个叶结点上，这是根结点的第二个子结点的键37将被24替代。</li>
</ul>
<h3 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B - 树的查找"></a>B - 树的查找</h3><p>现在我们假定，叶结点中没有重复建。同时我们假定 <strong>B - 树</strong> 是稠密索引，因而在数据文件中出现的每个查找键都会在叶结点中出现这些假定可以简化对<strong>B - 树</strong>操作的讨论。</p>
<p>假设我们有一棵<strong>B - 树</strong>索引，并且想找出查找键值为K的记录。我们从根到叶递归查找，查找过程为：</p>
<p><strong>基础</strong>  若我们处于叶结点上，我们就在其键值中查找。若第i个键是K，则第i个指针可让我们找的所需记录。</p>
<p><strong>归纳</strong>  若我们处于某个内部结点，且它的键为K1、K2、….、Kn。只有一个子结点可使我们找到具有键K的叶结点。如果K &lt; K1，则为第一个子结点；如果K1 &lt;= K &lt; K2，则为第二个子结点…在这一子结点上递归地运用查找过程。</p>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p><strong>B - 树</strong>不仅对搜寻单个查找键的查询很有用，而且对查找键值在某个范围内的查询也很有用。一般来说，<em>范围查询</em>在where子句中有一个项，该项将查找键与单个值或多个值相比较，例如：</p>
<pre><code>SELECT * FROM R WHERE R.k &gt; 40;
SELECT * FROM R WHERE R.k &gt;- 10 AND R.k &lt;= 25;
</code></pre><p>如果我们想在<strong>B - 树</strong>叶节点上找出范围[a, b]之间的所有键值，我们通过一次查找来找出键a。不论它是否存在，我们都可以到达可能出现a的叶结点，然后我们在该叶结点中查找键a或大于a的那些键。我们所找到的每个这样的键都有一个指针指向相应的记录，这些记录的键在所需的范围内。只要在当前叶结点中不存在比b大的键，我们就跟踪指向下一个叶结点的指针继续查找[a, b]之间的所有键值。</p>
<p>上面的查找算法当b为无穷时也有效，即项中只有一个下界而没上界。在这种情况下，我们查找键a可能出现的叶结点开始到最后一个叶结点的所有叶结点。a 为负无穷，那么不论我们处于<strong>B - 树</strong>的哪个结点，我们总被引向该结点的第一个子结点，即我们最终将找到第一个叶结点。然后我们按上述查找过程，仅在超过键b时停止查找。</p>
<h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B - 树的插入"></a>B - 树的插入</h3><p>当我们考虑如何插入一个新键到<strong>B - 树</strong>中时，我们就会发现<strong>B - 树</strong>优于简单多级索引的一些地方。这里介绍一下<strong>B - 树</strong>是如何做相应修改的。</p>
<ul>
<li>我们设法在适当的叶结点中为新键找到空闲空间，如果有的话，就将键放到那里。</li>
<li>如果在适当的叶结点中没有空间，我们就把该叶结点分裂成两个并且把其中的键分到这两个新结点中，使每个新结点有一半或刚好一超过一半的键</li>
<li>某一层的结点分裂在其上一层看来，相当于是要在这一较高的层次上插入一个新的键 -针对。因此，我们可以在这一较高层次上逆递归地使用这个插入策略；如果有空间，则插入；如果没有，则分裂这个父节点且继续向树的高层推进。</li>
<li>例外的情况是，如果我们试图插入键到根结点中并且根结点没有空间，那么我们就分裂根结点成两个结点且在更上一层创建一个新的根结点，这个新的根结点有两个刚分裂成的结点作为它的子结点。</li>
</ul>
<p>当我们分裂结点并在其父结点中插入时，我们需要小心地处理键。首先，假定N是一个容量为n个键的叶结点，却我们正视图给它插入第 (n+1) 个键和它相应的指针。我们创建一个新的结点M，该结点将成为N结点的兄弟，紧挨着N的右边。按键排序顺序的前 (n+1)/2 个键 -指针对保留在结点N中；而其他键 -指针对移到结点M中，注意，结点M和结点N中都有足够数量的键 -指针对，即至少有 (n+1)/2 个这样的键 -指针对。</p>
<p>现在，假定N是一个容量为n个键和n+1个指针的内部结点，并且由于下层结点的分裂N正好又被分配给第(n+2)个指针。我们执行下列步骤:</p>
<ol>
<li>创建一个新结点M，它将是N结点的兄弟且紧挨在N的右边。</li>
<li>按排序顺序将前（n+2)/2 个指针留在结点N中，而把剩下(n+2)/2 个指针移到结点M中。</li>
<li>前 n/2 个键保留在结点N中，而后 n/2 个键移到结点M中。注意，在中间的那个键总是被留出来，它既不在结点N也不在结点M。这一留出的键K表明通过M的第一个子结点可访问的最小键。尽管K不出现在N中也不出现在M中，但它代表通过M能到达的最小键值，从这种意义上来说它与M相连。因此，K将会成为结点N和M的父结点用来划分在这两个结点之间的查找。</li>
</ol>
<p>下图展示了一个<strong>B - 树</strong>的插入过程</p>
<p><img src="/img/btree_insert.png" alt=""></p>
<p><img src="/img/btree_insert2.png" alt=""></p>
<p><img src="/img/btree_insert3.png" alt=""></p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B - 树的删除"></a>B - 树的删除</h3><p>如果我们要删除一个具有给定键K的记录，我们必须先定位该记录和它在<strong>B - 树</strong>叶结点中的键 -指针对。删除过程中的这个部分主要是查找，然后我们删除记录本身并从<strong>B - 树</strong>中删除它的键 - 指针对。</p>
<p>如果发生删除的<strong>B - 树</strong>结点在删除后至少还有最小数目的键和指针，那就什么都不做。但是，结点有可能在删除之前正好具有最小的充满度，因此在删除后，就违背了对键数目的约束。这时，我们需要为这个键的数目仅次于最小数目的结点N做下面两件事之一，其中有一种情况需要沿着树往上递归地删除。</p>
<ol>
<li>如果与结点N相邻的兄弟中有一个的键和指针超过最小数目，那它的一个键 -指针对可以移到结点N中并保持键的顺序。结点N的父结点可能需要调整以反映这个新的情况。如果见到N的右边的兄弟M可提供一个键和指针，那么从结点M移到结点N的键一定是结点M的最小键。在结点M和结点N的父结点有一个表示通过M可访问到的最小键，必须增大该键值以反映新的M。</li>
<li>困难的情况是当相邻的两个兄弟结点中没有一个能提供键值给结点N时，不过，在这种情况下，我们有结点N和他的一个兄弟结点M这两个相邻的结点，其中后者的键数刚好为最小数，而前者的键数少于最小数。因此，它们合并一起也没有超过单个结点所允许的键和指针数。我们合并这两个结点，实际就是删除它们中的一个。我们需要调整父结点的键，然后删除父结点的一个键和指针。如果父结点现在足够满，那我们就完成了删除操作，否则，我们需要在父结点上递归的运用这个删除算法。</li>
</ol>
<h3 id="B-树的效率"><a href="#B-树的效率" class="headerlink" title="B - 树的效率"></a>B - 树的效率</h3><p><strong>B - 树</strong>使我们能实现记录的查找、插入和删除，而每个文件操作只需要很少的磁盘I/O。首先我们就注意到，如果每个块容纳的键数n相当大，那么，分裂或合并块的情况将会很少。此外，当这种操作必须时，绝大多数时候都被局限在叶结点，因此只有两个叶结点和它们的父结点受到影响。所以我们基本上可以忽略<strong>B - 树</strong>重组的开销。</p>
<p>然而，每次按给定查找键值查找记录都需要我们从根结点一直访问到叶结点，以找到指向记录的指针。因为我们只读<strong>B - 树</strong>的块，所以磁盘I/O数将是<strong>B - 树</strong>的层数加上一次（对查找而言）或两次（对插入或删除而言）处理记录本身的磁盘I/O。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/13/Python中的引用/" itemprop="url">
                  Python中的引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-13T09:53:50+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/13/Python中的引用/" class="leancloud_visitors" data-flag-title="Python中的引用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python不允许程序员来选择采用值传递还是引用传递，而是采用一种“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或列表）的引用，就能修改对象的原始值————相当于通过“传引用“来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象————相当于通过“传值”来传递对象。</p>
<p>事实上，当人们复制列表或字典时，就复制了对象列表的引用同，如果改变引用的值，则修改了原始的参数。</p>
<p>为了简化内存管理，Python通过引用计数机制实现自动垃圾回收功能，Python中的每个对象都有一个引用计数，用来计数该对象在不同场所分别被引用了多少次。每当引用一次Python对象，相应的引用计数就增1，每当消毁一次Python对象，则相应的引用就减1，只有当引用计数为零时，才真正从内存中删除Python对象。</p>
<h3 id="列表引用"><a href="#列表引用" class="headerlink" title="列表引用"></a>列表引用</h3><p>示例一:</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b.append(4)
&gt;&gt;&gt; print b
# output: [1,2,3,4]
&gt;&gt;&gt; print a
# output: [1,2,3,4]
</code></pre><p>这里把a的值赋给了b，相当于把a的引用给了b，这样改变b的值也就改变了a的值。</p>
<p>示例二:</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = a + []
&gt;&gt;&gt; b.append(4)
&gt;&gt;&gt; print b
# output: [1,2,3,4]
&gt;&gt;&gt; print a
# output: [1,2,3]
</code></pre><p>这里把 <strong>a+[ ]</strong> 的值赋给了b， <strong>a+[ ]</strong> 相当于一个新的变量，而不是a的引用传递，所以改变b的值不会同时也改变a。</p>
<p>示例三:</p>
<pre><code>def add_list(p):
     p = p + [1]
p1 = [1,2,3]
add_list(p1)
print p1
# output: [1, 2, 3]

def add_list(p):
    p += [1]
p2 = [1,2,3]
proc2(p2)
print p2
# output: [1, 2, 3, 1]
</code></pre><p>这主要是由于“=”操作符会新建一个新的变量保存赋值结果，然后再把引用名指向“=”左边，即修改了原来的p引用，使p成为指向新赋值变量的引用。而+=不会，直接修改了原来p引用的内容，事实上+=和=在python内部使用了不同的实现函数。</p>
<h3 id="字典引用"><a href="#字典引用" class="headerlink" title="字典引用"></a>字典引用</h3><p>示例一:</p>
<pre><code>&gt;&gt;&gt; a = {&quot;a&quot;:1,&quot;b&quot;:2}
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b[&quot;c&quot;] = 3
&gt;&gt;&gt; b
output: {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}
&gt;&gt;&gt; a
output: {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}
</code></pre><p>同列表引用一样，传递字典的时候其实传递的也是引用。</p>
<p>示例二:</p>
<pre><code>a = []
b = {&apos;num&apos;:0, &apos;sqrt&apos;:0}
resurse = [1,2,3]
for i in resurse:
  b[&apos;num&apos;] = i
  b[&apos;sqrt&apos;] = i * i
  a.append(b)
print a
output: [{&apos;num&apos;: 3, &apos;sqrt&apos;: 9}, {&apos;num&apos;: 3, &apos;sqrt&apos;: 9}, {&apos;num&apos;: 3, &apos;sqrt&apos;: 9}]
</code></pre><p>我们可能会觉得有点奇怪，因为我们想要的值可能是这个:</p>
<pre><code>output: [{&apos;num&apos;: 1, &apos;sqrt&apos;: 1}, {&apos;num&apos;: 2, &apos;sqrt&apos;: 4}, {&apos;num&apos;: 3, &apos;sqrt&apos;: 9}]
</code></pre><p>这是由于a中的元素就是b的引用，那怎么办呢？可以这样来修改:</p>
<pre><code>a = []
resurse = [1,2,3]
for i in resurse:
    a.append({&quot;num&quot;: i, &quot;sqrt&quot;: i * i})
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="PengShuang" />
          <p class="site-author-name" itemprop="name">PengShuang</p>
          <p class="site-description motion-element" itemprop="description">在路上，慢慢走！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">78</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/pengshuang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2176899852/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://bbs.byr.cn/" title="北邮人" target="_blank">北邮人</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.dongwm.com" title="小明明的博客" target="_blank">小明明的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PengShuang</span>
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("DKbLgBme7UkAx9JX6sM3D4Hj-gzGzoHsz", "GXjJ9Ox3pUGI9PJhm6CNfJGN");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
