<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在路上，慢慢走！">
<meta property="og:type" content="website">
<meta property="og:title" content="小沙文的博客">
<meta property="og:url" content="http://pengshuang.space/page/3/index.html">
<meta property="og:site_name" content="小沙文的博客">
<meta property="og:description" content="在路上，慢慢走！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小沙文的博客">
<meta name="twitter:description" content="在路上，慢慢走！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://pengshuang.space/page/3/"/>

  <title> 小沙文的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小沙文的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/谷歌三篇论文学习-MapReduce/" itemprop="url">
                  谷歌三篇论文学习(一): MapReduce
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T15:05:34+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/论文/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/21/谷歌三篇论文学习-MapReduce/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/21/谷歌三篇论文学习-MapReduce/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/21/谷歌三篇论文学习-MapReduce/" class="leancloud_visitors" data-flag-title="谷歌三篇论文学习(一): MapReduce">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="编程模型">编程模型</h3><p><strong>MapReduce</strong>  是一个编程模型，也是一个处理和生产超大数据集的算法模型的相关实现。用户首先创建一个 <strong>Map</strong> 函数处理一个基于 <strong>key/value pair</strong> 的数据集合，输出中间的基于 <strong>key/value pair</strong> 的数据集合；然后再创建一个 <strong>Reduce</strong> 函数来用来合并所有的具有相同中间<strong>key</strong>值的中间<strong>values</strong>值。现实世界中有很多满足上述处理模型的例子。</p>
<p><strong>MapReduce</strong> 编程模型的原理是:利用一个输入 <strong>key/value pair</strong> 集合来产生一个输出的 <strong>key/value pair</strong> 集合。 <strong>MapReduce</strong>  库的用户用两个函数表达这个计算: <strong>Map</strong> 和 <strong>Reduce</strong>。</p>
<p>用户自定义的 <strong>Map</strong> 函数接受一个输入的 <strong>key/value pair</strong> 值,然后产生一个中间 <strong>key/value pair</strong> 值的集合。 <strong>MapReduce</strong> 库把所有具有相同中间 key 值的中间 <strong>value</strong> 值集合在一起后传递给 <strong>Reduce</strong> 函数。</p>
<p>用户自定义的 <strong>Reduce</strong> 函数接受一个中间 <strong>key</strong> 的值和相关的一个 <strong>value</strong> 值的集合。 <strong>Reduce</strong> 函数合并这些 <strong>value</strong> 值，形成一个较小的 <strong>value</strong> 值的集合。一般的，每次 <strong>Reduce</strong> 函数调用只产生 0 或 1 个输出 <strong>value</strong> 值。通 常我们通过一个迭代器把中间 <strong>value</strong> 值提供给 <strong>Reduce</strong> 函数，这样我们就可以处理无法全部放入内存中的大量的 <strong>value</strong> 值的集合。</p>
<pre><code>map(<span class="type">String</span> key, <span class="type">String</span> value):
    // key: document name
    // value: document contents 
    <span class="keyword">for</span> each word w <span class="keyword">in</span> value:
        <span class="type">EmitIntermediate</span>(w, <span class="number">1</span>);

reduce(<span class="type">String</span> key, <span class="type">Iterator</span> values): 
    // key: a word
    // values: a list <span class="keyword">of</span> counts 
    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;
    <span class="keyword">for</span> each v <span class="keyword">in</span> values:
        <span class="literal">result</span> += <span class="type">ParseInt</span>(v); 
    <span class="type">Emit</span>(<span class="type">AsString</span>(<span class="literal">result</span>));
</code></pre><p><strong>Map</strong> 函数输出文档中的每个词、以及这个词的出现次数（在这个简单的例子里就是1）。<strong>Reduce</strong> 函数把Map函数产生的每一个特定的词的计数累加起来。</p>
<h3 id="MapReduce编程模型应用">MapReduce编程模型应用</h3><p>分布式的Grep：Map函数输出匹配模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</p>
<p>计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce 函数把相同的value值都累加起来，产生(URL，记录总数)结果。</p>
<p>倒转网络链接图：Map函数在源页面(source)中搜索所有的链接目标(target)并输出为(target, source)。Reduce 函数把给定链接目标(target)的链接组合成一个列表，输出(target, list(source))。</p>
<p>其他的一些应用场景有，每个主机的检索词向量，倒排索引以及分布式排序。</p>
<h3 id="MapReduce实现">MapReduce实现</h3><p>上图展示了<strong>MapReduce</strong> 实现中操作的全部流程。当用户调用 <strong>MapReduce</strong> 函数时，将发生下面的一 系列动作(下面的序号和图中的序号一一对应):</p>
<ol>
<li><p>用户程序首先调用的 <strong>MapReduce</strong> 库将输入文件分成 M 个数据片度,每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</p>
</li>
<li><p>这些程序副本中的有一个特殊的程序——<strong>master</strong>。副本中其它的程序都是 <strong>worker</strong> 程序，由 <strong>master</strong> 分配 任务。有 M 个 <strong>Map</strong> 任务和 R 个 <strong>Reduce</strong> 任务将被分配，<strong>master</strong> 将一个 <strong>Map</strong> 任务或 <strong>Reduce</strong> 任务分配给一个空闲的 <strong>worker</strong>。</p>
</li>
<li><p>被分配了 <strong>Map</strong> 任务的 <strong>worker</strong> 程序读取相关的输入数据片段，从输入的数据片段中解析出 <strong>key/value pair</strong>，然后把 <strong>key/value pair</strong> 传递给用户自定义的 <strong>Map</strong> 函数，由 <strong>Map</strong> 函数生成并输出的中间 <strong>key/value pair</strong>，并缓存在内存中。</p>
</li>
<li><p>缓存中的 <strong>key/value pair</strong> 通过分区函数分成 R 个区域,之后周期性的写入到本地磁盘上。缓存的 <strong>key/value pair</strong> 在本地磁盘上的存储位置将被回传给 <strong>master</strong>，由 <strong>master</strong> 负责把这些存储位置再传送给 <strong>Reduce worker</strong>。</p>
</li>
<li><p>当 <strong>Reduce worker</strong> 程序接收到 <strong>master</strong> 程序发来的数据存储位置信息后，使用 RPC 从 <strong>Map worker</strong> 所在主机的磁盘上读取这些缓存数据。当 <strong>Reduce worker</strong> 读取了所有的中间数据后，通过对 <strong>key</strong> 进行排序后使得具有相同 <strong>key</strong> 值的数据聚合在一起。由于许多不同的 <strong>key</strong> 值会映射到相同的 <strong>Reduce</strong> 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序,那么就要在外部进行排序。</p>
</li>
<li><p><strong>Reduce worker</strong> 程序遍历排序后的中间数据,对于每一个唯一的中间 <strong>key</strong> 值，<strong>Reduce worker</strong> 程序将这 个 <strong>key</strong> 值和它相关的中间 <strong>value</strong> 值的集合传递给用户自定义的 <strong>Reduce</strong> 函数。<strong>Reduce</strong> 函数的输出被追加到所属分区的输出文件。</p>
</li>
<li><p>当所有的 <strong>Map</strong> 和 <strong>Reduce</strong> 任务都完成之后，<strong>master</strong> 唤醒用户程序。在这个时候,在用户程序里的对 <strong>MapReduce</strong> 调用才返回。</p>
</li>
</ol>
<p>在成功完成任务之后，<strong>Mapreduce</strong> 的输出存放在R个输出文件中（对应每个 <strong>Reduce</strong> 任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件——他们经常把这些文件作为另外一个 <strong>Mapreduce</strong> 的输入， 或者在另外一个可以处理多个分割文件的分布式应用中使用。</p>
<h3 id="Master的数据结构">Master的数据结构</h3><p><strong>Master</strong> 持有一些数据结构，它存储每一个Map和Reduce任务（空闲、工作中或完成），以及Worker机器（非空闲任务的机器）的标识。</p>
<p><strong>Master</strong> 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，<strong>Master</strong> 存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，<strong>Master</strong>接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</p>
<h3 id="容错机制">容错机制</h3><p><strong>Master</strong> 周期性的 ping 每个 <strong>worker</strong>。如果在一个约定的时间范围内没有收到 <strong>worker</strong> 返回的消息，<strong>Master</strong> 将把这个任务标记为失效。所有由这个失效的 <strong>worker</strong> 完成的 <strong>Map</strong> 任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的 <strong>worker</strong>。 同样的，<strong>worker</strong> 失效时正在运行的 <strong>Map</strong> 或 <strong>Reduce</strong> 任务也将被重新置为空闲状态，等待重新调度。</p>
<p>当 <strong>worker</strong> 故障时，由于已经完成的 <strong>Map</strong> 任务的输出存储在这台机器上，<strong>Map</strong> 任务的输出已不接访问了，因此需要重新执行。而已经完成的 Reduce 任务的输出存储在全局文件系统上， 因此不需要再次执行。</p>
<p>当一个 <strong>Map</strong> 任务首先被 <strong>worker A</strong> 执行，之后由于 <strong>worker A</strong> 失效了又被调度到 <strong>worker B</strong> 执行，这个“重新执行”的动作会被通知给所有执行 <strong>Reduce</strong> 任务的 <strong>worker</strong>。任何还没有从 <strong>worker A</strong> 读取数据的 <strong>Reduce</strong> 任务 将从 <strong>worker B</strong> 读取数据。</p>
<p><strong>MapReduce</strong> 可以处理大规模 <strong>worker</strong> 失效的情况。比如，在一个 <strong>MapReduce</strong> 操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，<strong>MapReduce master</strong> 只需要简单的再次执行那些不可访问的 <strong>worker</strong> 完成的工作，之后继续执行未完成的任务，直到最终完成这个 <strong>MapReduce</strong>  操作。</p>
<h3 id="失效方面的处理机制">失效方面的处理机制</h3><p>当用户提供的 <strong>Map</strong> 和 <strong>Reduce</strong> 操作是输入确定性函数(即相同的输入产生相同的输出)时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p>
<p>我们依赖对 <strong>Map</strong> 和 <strong>Reduce</strong> 任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个 <strong>Reduce</strong> 任务生成一个这样的文件，而每个 <strong>Map</strong> 任务则生成 R 个这样的文件(一个 <strong>Reduce</strong> 任务对应一个文件)。当一个 <strong>Map</strong> 任务完成的时，<strong>worker</strong> 发送一个包含 R 个临时文件名的完成消息给 <strong>master</strong>。如果 <strong>master</strong> 从一个已经完成的 <strong>Map</strong> 任务再次接收到到一个完成消息，<strong>master</strong> 将忽略这个消息；否则，<strong>Master</strong> 将这 R 个文件的名字记录在数据结构里。</p>
<p>当 <strong>Reduce</strong> 任务完成时，<strong>Reduce worker</strong> 进程以原子的方式把临时文件重命名为最终的输出文件。如果同 一个 <strong>Reduce</strong> 任务在多台机器上执行,针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文 件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 <strong>Reduce</strong> 任务产生的数据。</p>
<h3 id="分区函数">分区函数</h3><p><strong>MapReduce</strong> 的使用者通常会指定 <strong>Reduce</strong> 任务和 <strong>Reduce</strong> 任务输出文件的数量(R)。我们在中间 key 上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用 <strong>hash</strong> 方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 <strong>key</strong> 值进行的分区将非常有用。比如，输出的 <strong>key</strong> 值是 <strong>URLs</strong>，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，<strong>MapReduce</strong> 库的用户需要􏰁供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的 <strong>URLs</strong> 保存在同一个输出文件中。</p>
<h3 id="顺序保证">顺序保证</h3><p>我们确保在给定的分区中，中间 <strong>key/value pair</strong> 数据的处理顺序是按照 <strong>key</strong> 值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按 <strong>key</strong> 值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p>
<h3 id="Combiner_函数">Combiner 函数</h3><p>在某些情况下，<strong>Map</strong> 函数产生的中间 <strong>key</strong> 值的重复数据会占很大的比重，并且，用户自定义的 <strong>Reduce</strong> 函数满足结合律和交换律。之前举例过的词频统计中，每个 <strong> Map </strong> 任务将产生成千上万个这样的任务<the, 1="">。所有的这些记录将通过网络被发送到一个单独的 <strong>Reduce</strong> 任务，然后这个 <strong>Reduce</strong> 任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的 <strong>combiner</strong> 函数，<strong>combiner</strong> 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</the,></p>
<p><strong>Combiner</strong> 函数在每台执行 <strong>Map</strong> 任务的机器上都会被执行一次。 一般情况下，<strong>Combiner</strong> 和 <strong>Reduce</strong> 函数是一样的。<strong>Combiner</strong> 函数和 <strong>Reduce</strong>函数之间唯一的区别是 <strong>MapReduce</strong> 库怎样控制函数的输出。<strong>Reduce</strong> 函数的输出被保存在最终的输出文件里，而 <strong>Combiner</strong> 函数的输出被写到中间文件里，然后被发送给 <strong>Reduce</strong> 任务。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/IP协议/" itemprop="url">
                  IP协议学习(一):IP基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T16:32:15+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/IP协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/IP协议/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/20/IP协议/" class="leancloud_visitors" data-flag-title="IP协议学习(一):IP基础知识">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_网络层与数据链路层的关系">1. 网络层与数据链路层的关系</h3><p>数据链路层提供直连两个设备之间的通信功能。与之相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。</p>
<p>数据链路只负责某一个区间之间的通信传输。IP负责将数据包发送给最终的目标地址。即点对点通信。</p>
<p>IP大致分为三大作用模块，它们是IP寻址、路由（最终节点为止的转发）以及IP分包与组包。</p>
<h3 id="2-_IP地址属于网络层地址">2. IP地址属于网络层地址</h3><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。数据链路的MAC地址是用来标识同一个链路中不同计算机的一种标识码。</p>
<p>而作为网络层的IP，我们常称为IP地址，也包含着这样一种地址信息。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP/IP通信中所有的主机或路由器必须设定自己的IP地址。（严格来说，要针对每块网卡至少配置一个或一个以上的IP地址）</p>
<p>不论一台主机与哪种数据链路连接，其IP地址的形式都保持不变。以太网、无线局域网、PPP等，都不会改变IP地址的形式。</p>
<h3 id="3-_路由控制">3. 路由控制</h3><p>路由控制（Routiong）是指将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。因此，一个数据包之所以能够成功第达到最终的目标地址，全靠路由控制。</p>
<p><strong>发送数据至最终目标地址</strong></p>
<p><strong>Hop</strong> 译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。下面这张图形象的表示了包转发的整个过程。</p>
<p><img src="/img/hop.png" alt=""></p>
<p><strong>一跳的范围</strong></p>
<p>一跳（1 Hop）是指利用数据链路层以下分层的功能传输数据帧的一个区间。</p>
<p>以太网等数据链路中使用MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。在一跳的这个区间内，电缆可以通过网桥或交换集线器相连，不会通过路由器或网关相连。</p>
<p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间（跳）在转发IP数据包时会分别指定下一跳的操作，直至包到达最终的目标地址。如果用购买火车票为例来说的话，IP就相当于在每次换乘时购买了标有下一个MAC地址的车票。</p>
<p><strong>路由控制表</strong></p>
<p>为了将数据包发送给目标主机，所有路由器都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。下图是一个路由控制表的示意图。</p>
<p><img src="/img/routing.png" alt=""></p>
<h3 id="4-_数据链路的抽象化">4. 数据链路的抽象化</h3><p>IP是实现多个数据链路之间通信的协议。数据链路根据种类的不同各有特点。对这些不同数据链路的相异特性进行抽象化是IP的重要作用之一。不论底层数据链路使用以太网LAN亦或是PPP，都将被一视同仁。</p>
<p>不同数据链路有个很大的区别，就是它们各自的最大传输单播（MTU）不同。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p>
<p>为了解决这个问题，IP进行分片处理(IP Fragmentation)。所谓分片处理，就是将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。</p>
<h3 id="5-_IP属于面向无连接型">5. IP属于面向无连接型</h3><p>IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。之所以IP要面向无连接，一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。IP在需要有连接时，可以委托上一层提供此服务，因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/hive模式设计/" itemprop="url">
                  《Hive编程指南》学习笔记：Hive模式设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T10:58:22+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/hive模式设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/hive模式设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/20/hive模式设计/" class="leancloud_visitors" data-flag-title="《Hive编程指南》学习笔记：Hive模式设计">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_按天划分的表">1. 按天划分的表</h3><pre><code>hive&gt; CREATE TABLE supply (id <span class="built_in">int</span>, part <span class="built_in">string</span>, quantity <span class="built_in">int</span>)
    &gt; PARTITIONED BY (<span class="built_in">int</span> <span class="built_in">day</span>);

hive&gt; ALTER TABLE supply add PARTITION (<span class="built_in">day</span>=<span class="number">20110102</span>)
hive&gt; ALTER TABLE supply add PARTITION (<span class="built_in">day</span>=<span class="number">20110103</span>)
...

hive&gt; .... load data ....

hive&gt; <span class="keyword">SELECT</span> part, quantity FROM supply
    &gt; WHERE <span class="built_in">day</span> &gt;= <span class="number">20110102</span> <span class="keyword">AND</span> <span class="built_in">day</span> &lt; <span class="number">20110103</span> <span class="keyword">AND</span> quantity &lt; <span class="number">4</span>;
</code></pre><h3 id="2-_关于分区">2. 关于分区</h3><p>在Hive中，通过创建分区可以优化一些查询，但如果创建的分区很多很多的话，反而会对其他一些重要的查询不利，因为HDFS用于设计存储数百万的大文件，而非数十亿的小文件。使用过多的分区可能导致的一个问题就是会创建大量的非必须的Hadoop文件和文件夹。</p>
<p>MapReduce 会将一个任务（job）转换为多个任务（task）。默认情况下，每个task都是一个新的JVM实例，都需要开启和销毁的开销。对于小文件来说，每个文件都会对应一个task。在一些情况下，JVM开启和销毁的时间中销毁可能会比实际处理数据的时间消耗更长！</p>
<p>因此，一个理想的分区方案不应该导致产生太多的分区和文件夹目录，并且每个目录下的文件应该足够得大，应该是文件系统中块大小的若干倍。</p>
<p>按时间范围进行分区的一个好的策略就是按照不同的时间粒度来确定合适大小的数据积累量，而且安装这个时间粒度。随着时间的推移，分区数量的增长是“均匀的”，而且每个分区下包含的文件大小至少是文件系统中块的大小的若干倍。这个平衡可以保持使分区足够大，从而优化一般情况下查询的数据吞吐量。同时有必要考虑这中粒度级别在未来是否是适用的，特别是查询中WHERE子句选择较小粒度的范围的情况：</p>
<pre><code>hive&gt; CREATE TABLE weblogs (url <span class="built_in">string</span>, time <span class="built_in">long</span>, state <span class="built_in">string</span>, 
city <span class="built_in">string</span> )
    &gt; PARTITIONED <span class="keyword">BY</span> (day int);
hive&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weblogs <span class="keyword">WHERE</span> day=<span class="number">20110102</span>;
</code></pre><p>也可以使用2个级别的分区，并且适用不同的维度:</p>
<pre><code>hive&gt; CREATE TABLE weblogs (url <span class="built_in">string</span>, time <span class="built_in">long</span>, city <span class="built_in">string</span> )
    &gt; PARTITIONED <span class="keyword">BY</span> (day int, state <span class="built_in">string</span>);
hive&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weblogs <span class="keyword">WHERE</span> day=<span class="number">20110102</span>;
</code></pre><h3 id="3-_唯一键和标准化">3. 唯一键和标准化</h3><p>关系型数据库通常使用唯一键、索引和标准化来存储数据集，通常是全部或者大部分存储到内存的。然而，Hive没有主键或基于序列密钥生成的自增键的概念。</p>
<p>避免标准化的主要原因是为了最小化磁盘寻道，比如那些通常需要外键关系的情况。非标准化数据允许被扫描或写入到大的，连续的磁盘存储区域，从而优化磁盘驱动器的I/O性能。然而，非标准化数据可能导致数据重复，有导致数据不一致的风险。</p>
<h3 id="4-_同一份数据多种处理">4. 同一份数据多种处理</h3><p>Hive 本身提供一个独特的语法，它可以从一个数据源产生多个数据聚合，而无需每次聚合都要重新扫描一次。对于大的数据输入集来说，这个优化可以节约非常可观的时间。</p>
<p>常用的方法：</p>
<pre><code>hive&gt; FROM history
    &gt; INSERT OVERWRITE sales <span class="keyword">SELECT</span> * <span class="keyword">WHERE</span> action=<span class="string">"purchased'
    &gt; INSERT OVERWRITE credits SELECT * WHERE actions="</span>returned<span class="string">';</span>
</code></pre><h3 id="5-_对于每个表的分区">5. 对于每个表的分区</h3><p>很多的ETL处理过程会涉及到多个处理步骤，而每个处理步骤可能会产生一个或多个临时表，这些表仅供下一个job使用。下面的这个例子即在中间表内部使用分区，这样的话就不会再计算某一天的数据时会发生前一天的数据被 <strong>INSERT OVERWRITE</strong> 语句覆盖掉的情况。</p>
<pre><code>$ hive -hiveconf dt=<span class="number">2011</span>-<span class="number">01</span>-<span class="number">01</span>
hive&gt; <span class="type">INSERT</span> <span class="type">OVERWRITE</span> table distinct_ip_logs
    &gt; <span class="type">PARTITION</span> (hit_date=${dt})
    &gt; <span class="type">SELECT</span> <span class="keyword">distinct</span>(ip) <span class="keyword">as</span> ip <span class="keyword">from</span> weblogs
    &gt; <span class="type">WHERE</span> hit_date = '${hiveconf:dt}';

hive&gt; <span class="type">CREATE</span> <span class="type">TABLE</span> state_city_for_day (state <span class="type">string</span>, city <span class="type">string</span>)
    &gt; <span class="type">PARTITIONED</span> <span class="type">BY</span> (hit_date <span class="type">string</span>)

hive&gt; <span class="type">INSERT</span> <span class="type">OVERWRITE</span> table state_city_for_day <span class="type">PARTITION</span>(${hivecong:df})
    &gt; <span class="type">SELECT</span> <span class="keyword">distinct</span>(state, city) <span class="type">FROM</span> distinct_ip_in_logs
    &gt; <span class="type">JOIN</span> geodata <span class="type">ON</span> (distinct_ip_in_logs.ip = geodata.ip)
    &gt; <span class="type">WHERE</span> (hit_date = '${hiveconf:dt}');
</code></pre><p>这种方法有个缺点，就是用户将需要管理中间表并删除旧分区。</p>
<h3 id="6-_分桶表数据存储">6. 分桶表数据存储</h3><p>分区提供一个隔离数据和优化查询的便利的方式。但是并非所有的数据集都可以形成合理的分区，特别是之前所提过的要确定合适的划分大小。</p>
<p>分桶是将数据集分解成更容易管理的若干部分。我们假设有个表的一级分区是dt，代表日期，二级分区是<strong>user_id</strong>，那么这种划分方式可能导致太多的小分区。但是，如果我们对表进行分桶，并使用<strong>user_id</strong>字段作为分桶字段，则字段值会根据用户指定的值进行哈希分发到桶中。同一个<strong>user_id</strong>下的记录通常会存储到同一个桶内。同一个<strong>user_id</strong>下的记录通常会存储到同一个桶内，假设用户数要比桶数多得多，那么每个桶内就将会包含多个用户的记录：</p>
<pre><code>hive&gt; CREATE TABLE weblog (user_id INT, url <span class="built_in">STRING</span>, source_ip <span class="built_in">STRING</span>)
    &gt; PARTITIONED <span class="keyword">BY</span> (dt <span class="built_in">STRING</span>)
    &gt; CLUSTERED <span class="keyword">BY</span> (user_id) <span class="keyword">INTO</span> <span class="number">96</span> BUCKETS;
</code></pre><p>在使用 <strong>INSERT … TABLE</strong> 语句时，我们需要设置一个属性来强制Hive为目标表的分桶初始化过程设置一个正确的reducer个数。然后我们再执行一个查询来填充分区。例如：</p>
<pre><code>hive&gt; <span class="keyword">SET</span> hive.enforce.bucketing = <span class="literal">true</span>

hive&gt; <span class="keyword">FROM</span> raw_logs
    &gt; INSERT OVERWRITE TABLE weblog
    &gt; PARTITION (dt=<span class="string">"2015-01-01"</span>)
    &gt; <span class="keyword">SELECT</span> user_id, url, source_ip <span class="keyword">WHERE</span> dt=<span class="string">"2015-01-01"</span>;
</code></pre><p>如果我们没有使用 <strong>hive.enforce.bucketing</strong> 属性，那么我们就需要自己设置和分桶个数想匹配的 <strong>reducer</strong> 个数。例如，使用 <strong>set.mapred.reduce.tasks=96</strong>，然后在 <strong>INSERT</strong> 语句中，需要在 <strong>SELECT</strong> 语句后增加 <strong>CLUSTER BY</strong> 语句。</p>
<p>分桶有几个优点，因为桶的数量是固定的，所以它没有数据波动，故对于抽样再合适不过。</p>
<h3 id="7-_为表增加列">7. 为表增加列</h3><p>Hive允许在原始数据文件之上定义一个模式，而不像很多的数据库那样，要求必须以特定的格式转换和插入数据。这样的分离方式的好处是，当为数据文件增加新的字段时，可以容易地适应表定义的模式。</p>
<p>下面来举个例子：</p>
<pre><code>hive&gt; CREATE TABLE weblogs (version LONG, url <span class="built_in">STRING</span>)
    &gt; PARTITIONED <span class="keyword">BY</span> (hit_date int)
    &gt; ROW FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">'\t'</span>;

hive&gt; <span class="subst">!</span> cat log1<span class="built_in">.</span>txt
<span class="number">1</span>    /login
<span class="number">1</span>    /logout

hive&gt; LOAD <span class="built_in">DATA</span> <span class="built_in">LOCAL</span> INPATH <span class="string">'log1.txt'</span> int weblogs partition(<span class="number">20150101</span>);

hive&gt; <span class="keyword">SELECT</span> * FROM weblogs;
<span class="number">1</span>    /mystuff    <span class="number">20150101</span>
<span class="number">1</span>    /toys        <span class="number">20150101</span>
</code></pre><p>随着时间的推移，可能会为底层数据增加一个新字段。下面是为数据新增 <strong>user_id</strong>字段的过程。</p>
<pre><code>hive&gt; ! cat log2.txt
<span class="number">2</span>    /cars    bob
<span class="number">2</span>    /stuff    terry

hive&gt; ALTER TABLE weblogs ADD COLUMNS (user_id <span class="built_in">string</span>)<span class="comment">;</span>

hive&gt; LOAD DATA <span class="keyword">LOCAL</span> INPATH <span class="string">'log2.txt'</span> <span class="built_in">int</span> weblogs partition(<span class="number">20150102</span>)<span class="comment">;</span>

hive&gt; <span class="keyword">SELECT</span> * from weblogs
<span class="number">1</span>    /mystuff    <span class="number">20150101</span>     <span class="literal">NULL</span>
<span class="number">1</span>    /toys        <span class="number">20150101</span>    <span class="literal">NULL</span>
<span class="number">2</span>    /cars        <span class="number">20150102</span>     bob
<span class="number">2</span>    /stuff        <span class="number">20150102</span>    terry
</code></pre><p>但是这种方式，无法在已有字段的开始或中间增加新字段。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/HiveQL-视图/" itemprop="url">
                  《Hive编程指南》学习笔记：HiveQL:视图与索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T21:56:00+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/HiveQL-视图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/HiveQL-视图/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/16/HiveQL-视图/" class="leancloud_visitors" data-flag-title="《Hive编程指南》学习笔记：HiveQL:视图与索引">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>视图可以允许保存一个查询并像对待表一样对这个查询进行操作。这是一个逻辑结构，而非物化的一个表结构。</p>
<h3 id="1-_使用视图来降低查询的复杂度">1. 使用视图来降低查询的复杂度</h3><p>例如，一个具有嵌套子查询的查询：</p>
<pre><code>FROM (
    <span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">JOIN</span> cart
        <span class="keyword">ON</span> (cart.people_id = people.<span class="keyword">id</span>) <span class="keyword">WHERE</span> firstname = <span class="string">'John'</span>
    ) a <span class="keyword">SELECT</span> a.lastname <span class="keyword">WHERE</span> a.<span class="keyword">id</span> = <span class="number">3</span>;</span>
</code></pre><p>将上面这个嵌套子查询变成一个视图：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> shorter_join <span class="keyword">AS</span>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">JOIN</span> cart
<span class="keyword">ON</span> (cart.people_id = people.<span class="keyword">id</span>) <span class="keyword">WHERE</span> firstname=<span class="string">'john'</span>;</span>
</code></pre><p>现在就可以像操作表一样操作这个视图了：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> lastname <span class="keyword">FROM</span> shorter_join <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span>
</code></pre><h3 id="2-_使用视图来限制基于条件过滤的数据">2. 使用视图来限制基于条件过滤的数据</h3><p>视图有一个常见的使用场景就是基于一个或多个列的值来限制输出结果，</p>
<h4 id="(1)_通过视图来限制输入出结果：">(1) 通过视图来限制输入出结果：</h4><pre><code>hive&gt; CREATE TABLE userinfo (
      firstname <span class="built_in">string</span>, lastname <span class="built_in">string</span>, ssn <span class="built_in">string</span>, password <span class="built_in">string</span>);
hive&gt; CREATE VIEW safer_user_info <span class="keyword">AS</span>
      <span class="keyword">SElECT</span> firstname, lastname <span class="keyword">FROM</span> userinfo;
</code></pre><h4 id="(2)_通过使用视图来只暴露部分结果：">(2) 通过使用视图来只暴露部分结果：</h4><pre><code>hive&gt; CREATE TABLE employee (firstname <span class="built_in">string</span>, lastname <span class="built_in">string</span>,
      ssn <span class="built_in">string</span>, password <span class="built_in">string</span>, department <span class="built_in">string</span>);
 hive&gt; CREATE VIEW techops_employee <span class="keyword">AS</span> 
       <span class="keyword">SELECT</span> firstname, lastname,ssn <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> department=<span class="string">"techops"</span>;
</code></pre><h3 id="3-_创建索引">3. 创建索引</h3><p>下面以为一个分区表创建索引为例：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (
    <span class="keyword">name</span>    <span class="keyword">STRING</span>,
    salary    <span class="built_in">FLOAT</span>,
    subordinates    <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,
    deductions    <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>, <span class="built_in">FLOAT</span>&gt;,
    address    <span class="keyword">STRUCT</span>&lt;street:<span class="keyword">STRING</span>, city:<span class="keyword">STRING</span>, state:<span class="keyword">STRING</span>, zip:<span class="built_in">INT</span>&gt;
    )
    PARTITIONED <span class="keyword">BY</span> (country <span class="keyword">STRING</span>, state <span class="keyword">STRING</span>);</span>
</code></pre><p>下面对分区字段country建立索引：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> employees_index
<span class="keyword">ON</span> TBALE employess (country)
<span class="keyword">AS</span> <span class="string">'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler'</span>
<span class="keyword">WITH</span> <span class="keyword">DEFERRED</span> <span class="keyword">REBUILD</span>
IDXPROPERTIES (<span class="string">'creator = '</span>me<span class="string">', '</span>created_at<span class="string">' = '</span>some_time<span class="string">')
IN TABLE employee_index_table
PARTITIONED BY (country_name)
COMMENT '</span>Employees indexed <span class="keyword">by</span> country <span class="keyword">and</span> <span class="keyword">name</span>.<span class="string">';</span></span>
</code></pre><p>如果在这里我省略掉PARTITIONED BY语句的话，那么索引将会包含原始表的所有分区。</p>
<p>AS … 语句指定了索引处理器，也就是一个实现了索引接口的Java类。</p>
<p>如果要求索引处理器在一张新表中保留索引数据，会使用到 IN_TABLE… 子句。</p>
<h4 id="Bitmap_索引">Bitmap 索引</h4><p>如果想使用Bitmap索引，那么将</p>
<pre><code><span class="title">AS</span> <span class="string">'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler'</span>
</code></pre><p>替换为：</p>
<pre><code><span class="title">AS</span> <span class="string">'BITMAP'</span>
</code></pre><p>即可。</p>
<h3 id="4-_重建索引">4. 重建索引</h3><p>如果用户指定了 <strong>DEFERRED REBUILD</strong>， 那么新索引将呈现空白状态。在任何时候，都可以进行第一次索引创建或者使用ALTER INDEX对索引进行重建。</p>
<pre><code><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> employees_index
<span class="keyword">ON</span> <span class="keyword">TABLE</span> employees
<span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>)
<span class="keyword">REBUILD</span></span>
</code></pre><p>如果省略掉PARTITION，那么将会对所有分区进行重建索引。</p>
<h3 id="5-_显示索引">5. 显示索引</h3><pre><code><span class="operator"><span class="keyword">SHOW</span> (FORMATTED) <span class="keyword">INDEX</span> <span class="keyword">on</span> employees;</span>
</code></pre><p>关键字FORMATTED是可选的。增加这个关键字可以使输出中包含有列名称。用户还可以替换INDEX为INDEXES，这样输出中就可以列举多个索引信息了。</p>
<h3 id="6-_删除索引">6. 删除索引</h3><p>如果有索引表的话，删除一个索引将会删除这个索引表：</p>
<pre><code><span class="operator"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> employees_index <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees;</span>
</code></pre><p>Hive不允许用户直接使用 <strong>DROP TABLE</strong> 语句之前删除索引表。如果被索引的表被删除了，那么其对应的索引和索引表也会被删除。如果原始表的某个分区被删除了，那么这个分区对应的分区索引也同时会被删除掉。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/TCP-IP基础知识/" itemprop="url">
                  TCP/IP协议分层模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T22:01:00+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/15/TCP-IP基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/15/TCP-IP基础知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/15/TCP-IP基础知识/" class="leancloud_visitors" data-flag-title="TCP/IP协议分层模型">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_物理层（硬件）">1. 物理层（硬件）</h3><p>TCP/IP的最底层是负责数据传输的硬件。</p>
<h3 id="2-_数据链路层（网络接口层）">2. 数据链路层（网络接口层）</h3><p>数据链路层利用以太网中的数据链路层进行通信，因此属于接口层。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p>
<h3 id="3-_网络层（互联网层）">3. 网络层（互联网层）</h3><p>网络层使用IP协议，它相当于OSI模型中的第三层网络层。IP协议基于IP地址转发分包数据。TCP/IP分层中的网络层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过网络层转发分组数据包的功能。</p>
<h4 id="IP">IP</h4><p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间使用IP地址作为主机的标识。虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输。</p>
<h4 id="ICMP">ICMP</h4><p>IP数据包在发送途中一旦发送异常导致无法到达对端目标地址时，需要给发送端发送一个发送异常的通知。ICMP就是被用来诊断网络的健康状况。</p>
<h4 id="ARP">ARP</h4><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p>
<h3 id="4-_传输层">4. 传输层</h3><p>传输层主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的事端口号。</p>
<h4 id="TCP">TCP</h4><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p>
<h4 id="UDP">UDP</h4><p>UDP有别于TCP，它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据。UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p>
<h3 id="5-_应用层（会话层以上的分层）">5. 应用层（会话层以上的分层）</h3><p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。</p>
<p>HTTP协议属于应用层的协议，HTML和电子邮件属于表示层协议。</p>
<h3 id="6-_TCP/IP分层模型及通信示例">6. TCP/IP分层模型及通信示例</h3><p>以甲向乙发送电子邮件为例，来讲解TCP/IP的通信过程。</p>
<h4 id="应用程序处理">应用程序处理</h4><p>启动应用新建邮件，填写好内容并点击发送之后，应用程序会进行编码处理，这些编码相当于OSI的表示层的功能。编码转化后，实际邮件不一定会马上被发送出去，因为有些邮件的软件有一次同时发送多个邮件的功能。像这种何时建立通信连接何时发送数据的管理功能，其实属于OSI参考模型中会话层的功能。</p>
<p>应用在发送电子邮件的那一刻建立TCP连接，从而利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，再做实际的转发处理。</p>
<h4 id="TCP模块的处理">TCP模块的处理</h4><p>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号。（用以识别发送主机跟接收主机上的应用）、序号（用以发送的包中哪部分是数据）以及校验和（用以判断数据是否被损坏）。随后将附加了TCP首部的包再发送给IP。</p>
<h4 id="IP模块的处理">IP模块的处理</h4><p>IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端加上自己的IP首部。因此，IP数据包中的IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据是TCP还是UDP的信息。</p>
<h4 id="网络接口（以太网驱动）的处理">网络接口（以太网驱动）的处理</h4><p>从IP传过来的IP包，对于以太网驱动来说不过就是数据。给这数据附上以太网首部并进行发送处理。以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端。</p>
<h4 id="经过数据链路的包">经过数据链路的包</h4><p>每个包首部中至少都会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。经过每个协议分层时，都必须有识别包发送端和接收端的信息。以太网会用MAC地址，IP会用IP地址，而TCP/UDP会用端口号作为识别两端主机的地址。分层中包的结构如下所示：</p>
<p><img src="/img/tcp.png" alt=""></p>
<p>此外每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP/UDP中两个端口的端口号都起着识别协议类型的作用。</p>
<h4 id="数据包接收处理">数据包接收处理</h4><p>包的接收流程是发送流程的逆序过程。</p>
<h4 id="网络接口（以太网驱动）的处理-1">网络接口（以太网驱动）的处理</h4><p>主机收到以太网包以后，首先从以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是则丢弃。而如果接收到了恰好是发送给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型（IP或其他诸如ARP的协议）。如果以太网首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p>
<h4 id="IP模块的处理-1">IP模块的处理</h4><p>IP模块收到IP包首部以及后面的数据部分后，如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议。如果上一层是TCP就将IP包首部之后的传给TCP处理；UDP类似。对于有路由器的情况，接收端地址往往不是自己的地址，此时需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。</p>
<h4 id="TCP模块的处理-1">TCP模块的处理</h4><p>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按序号接收数据。最后检查端口号，确定具体的应用程序。数据接收完毕之后，接收端返回一个“确认回执”给发送端。</p>
<p>数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<h4 id="应用程序的处理">应用程序的处理</h4><p>接收端应用程序会直接接收发送端发送的数据，如果确认是发送给自己的，则邮件会被保存到本机的硬盘上。如果保存能正常进行，那么会返回给一个“处理正常”的回执给发送端。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/理解有连接和无连接/" itemprop="url">
                  理解计算机网络中的传输方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T09:05:01+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/15/理解有连接和无连接/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/15/理解有连接和无连接/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/15/理解有连接和无连接/" class="leancloud_visitors" data-flag-title="理解计算机网络中的传输方式">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_面向有连接型与面向无连接型">1. 面向有连接型与面向无连接型</h3><p>通过网络发送数据，大致可以分为面向有连接与面向无连接类型</p>
<p>(1) 面向无连接型包括以太网、IP、UDP等协议。</p>
<p>(2) 面向有连接型包括ATM、帧中继、TCP。</p>
<h4 id="面向有连接型">面向有连接型</h4><p>面向有连机型中，在发送数据之前，需要在收发主机之间连接一条通信线路。并且必须在通信传输前后，专门进行建立和断开连接的处理。如果与对端之间无法通信，就可以避免发送无谓的数据</p>
<h4 id="面向无连接型">面向无连接型</h4><p>面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据。反之，接收端也永远不知道自己会在何时从哪里接收到数据。</p>
<h3 id="2-_电路交换与分组交换">2. 电路交换与分组交换</h3><h4 id="电路交换">电路交换</h4><p>计算机之间在发送数据时，需要通过交换机与目标主机建立通信电路。我们将连接电路称为建立连接。建立好连接以后，用户就可以一直使用这条电路，直到该连接被断开为止。</p>
<h4 id="分组交换">分组交换</h4><p>在分组交换中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。因此，分组交换也有另一个名称：蓄积交换。</p>
<p>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条共享线路。</p>
<h3 id="3-_根据接收端数量分类">3. 根据接收端数量分类</h3><p>网络通信中，也可以根据目标地址的个数以及后续的行为对通信进行分类。如广播、多播等。</p>
<h4 id="单播（Unicast）">单播（Unicast）</h4><p>1对1通信</p>
<h4 id="广播（Broadcast）">广播（Broadcast）</h4><p>广播指将消息从1台主机发送给与之相连的所有其他主机。典型的例子是电视播放。</p>
<h4 id="多播（Multicast）">多播（Multicast）</h4><p>多播与广播类似，也是将消息发送给多个接收主机。不同之处在于多播要限定某一组作为接收端。多播通信最典型的例子是电视会议。</p>
<h4 id="任播_（Anycast）">任播 （Anycast）</h4><p>任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/OSI7层通信模型/" itemprop="url">
                  OSI7层通信模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T22:32:15+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/OSI7层通信模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/OSI7层通信模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/14/OSI7层通信模型/" class="leancloud_visitors" data-flag-title="OSI7层通信模型">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>理解TCP/IP的7层模型，可以从每一层的功能入手，每个分层上的协议规定了该分层中数据首部的格式已经首部与处理数据的顺序。下面以一个实际应用：主机A向主机B发送邮件来解释7层通信模型。</p>
<h3 id="1-_应用层">1. 应用层</h3><p>应用层为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议。两个要通信的主机之间通过它们各自的应用层进行通信，最终实现主机A向主机B发送邮件，以及邮件的存储。</p>
<h3 id="2-_表示层">2. 表示层</h3><p>将数据从主机特有的格式转换为网络标准传输格式，数据被转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复为“该计算机特定的数据格式”，然后再进行相应处理。 这样使得异构的机型之间能保持数据一致性。表示层是进行“统一的网络数据格式”与“某一台计算机或一款软件特有的数据格式”之间相互转换的分层。</p>
<h3 id="3-_会话层">3. 会话层</h3><p>决定采用哪种连接方法是会话层的主要责任。会话层也想应用层或表示层那样，在其收到的数据前端附加首部或标签信息后再转发给下一层。而这些首部或标签中记录着数据传送顺序的信息。</p>
<h3 id="4-_传输层">4. 传输层</h3><p>会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理。会话层只对何时建立连接、何时发送数据等问题进行管理，并不具有实际传输数据的功能。真正负责在网络上传输具体数据的是会话层以下的各层。</p>
<p>进行建立连接或断开连接处理，在两个主机之间创建逻辑上的通信连接即是传输层的主要作用。此外，传输层为确保所传输的数据到达目标地址，会在通信两端的计算机之间进行确认，如果数据没有到达，则要负责进行重传。未来确保可靠性，在这一层也会为所要传输的数据附加首部以识别这一分层的数据。实际将传输给对端的处理是由网络层来完成的。</p>
<h3 id="5-_网络层">5. 网络层</h3><p>从主机A到主机B的数据通信处理。网络层的作用是在网络与网络相互连接的环境中，将数据从发生端主机发送到接收端主机。网络层负责将数据发送至最终目标地址，数据链路层负责实现每一个区间内的通信。</p>
<h3 id="6-_数据链路层">6. 数据链路层</h3><p>通信传输实际上是通过物理的传输介质实现的。数据链路层的作用是在这些通过传输介质相互连接的设备之间进行数据处理。网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p>
<h3 id="7-_物理层">7. 物理层</h3><p>将数据的0、1转换为电压和脉冲光传输给物理的传输介质，而相互直连的设备之间使用地址实现传输。这种地址被称为MAC地址，也可称为物理地址。</p>
<h3 id="8-_接收端的处理">8. 接收端的处理</h3><p>接收端从物理层开始接收到的数据逐层发送给上一分层进行处理，从而使用户最终接收到发送端发送过来的信息。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/Hive编程指南笔记1/" itemprop="url">
                  《Hive编程指南》学习笔记：HiveQL数据操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T22:30:48+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/13/Hive编程指南笔记1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/13/Hive编程指南笔记1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/13/Hive编程指南笔记1/" class="leancloud_visitors" data-flag-title="《Hive编程指南》学习笔记：HiveQL数据操作">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-_使用正则表达式来指定列">1. 使用正则表达式来指定列</h3><pre><code>hive&gt; <span class="keyword">SELECT</span> symbol, <span class="string">'price.*'</span> <span class="keyword">FROM</span> stocks;
</code></pre><p>上面的查询从表stocks中选择symbol列和所有以price作为前缀的列</p>
<h3 id="2-_使用列值进行计算">2. 使用列值进行计算</h3><pre><code>hive&gt; SELECT upper(<span class="property">name</span>), salary, deductions[<span class="string">"Federal 
      Taxes"</span>],<span class="command">round</span>(salary * (<span class="number">1</span> - deductions[<span class="string">"Federal Taxes"</span>])) 
      FROM employees;
</code></pre><p>我们可以查询得到转换为大写的雇员姓名，雇员对应的薪水，需要缴纳的联邦税收比例以及扣除税收后再进行取整所得的税后薪资。</p>
<h3 id="3-_HIVE相关函数(常用的）">3. HIVE相关函数(常用的）</h3><ul>
<li>数学函数</li>
</ul>
<table>
<thead>
<tr>
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>floor(DOUBLE d)</td>
<td>d是DOUBLE类型的，返回&lt;=d的最大BIGINT型值</td>
</tr>
<tr>
<td>ceil(DOUBLE d),ceiling(DOUBLE d)</td>
<td>d是DOUBLE类型的，返回&gt;=d的最小BIGINT型值</td>
</tr>
<tr>
<td>exp(DOUBLE d)</td>
<td>返回e的d幂次方，返回的是个DOUBLE型值</td>
</tr>
<tr>
<td>ln(DOUBLE d)</td>
<td>以自然数为底d的对数，返回DOUBLE型值</td>
</tr>
<tr>
<td>pow(DOUBLE d,DOUBLE p)</td>
<td>计算d的p次幂</td>
</tr>
</tbody>
</table>
<ul>
<li>聚合函数</li>
</ul>
<table>
<thead>
<tr>
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count(*)</td>
<td>计算总行数</td>
</tr>
<tr>
<td>count(expr)</td>
<td>计算提供的expr表达式的值非NULL的行数</td>
</tr>
<tr>
<td>count(DISTINCT expr)</td>
<td>计算提供的expr表达式的值非NULL的行数</td>
</tr>
<tr>
<td>sum(col)</td>
<td>计算指定列值的和</td>
</tr>
<tr>
<td>sum(DISTINCT col)</td>
<td>计算排重后值的和</td>
</tr>
<tr>
<td>avg(col)</td>
<td>计算指定列的值的平均值</td>
</tr>
<tr>
<td>avg(DISTINCT col)</td>
<td>计算排重后值的平均值</td>
</tr>
</tbody>
</table>
<ul>
<li>表生成函数</li>
</ul>
<p>功能与聚会函数相反，其可以将单列扩展成多列或者多行</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>explode(ARRAY array)</td>
<td>返回0到多行结果，每行都对应输入的array数组中的一个元素</td>
</tr>
<tr>
<td>explode(MAP map)</td>
<td>返回0到多行结果，每行对应每个map键-值对，其中一个字段是map的键，另一个字段对应map的值</td>
</tr>
<tr>
<td>explode（ARRAY<type> a)</type></td>
<td>对于a中的每个元素，explode()都会生成一行记录包含这个元素</td>
</tr>
<tr>
<td>inline(ARRAY<struct[,struct]>)</struct[,struct]></td>
<td>将结构体数组提取出来并插入到表中</td>
</tr>
<tr>
<td>json_tuple(STRING jsonStr,p1,p2, … ,pn)</td>
<td>对输入的JSON字符串进行处理,一次调用获得多个键值</td>
</tr>
<tr>
<td>parse_url_tuple(url,partname1,partname2, … ,partnameN)</td>
<td>从URL中解析出Nge部分信息</td>
</tr>
<tr>
<td>stack(INT n,col1, … ,colM)</td>
<td>把M列转换成N行，每行有M/N个字段，n需要为常数</td>
</tr>
</tbody>
</table>
<ul>
<li>其他函数</li>
</ul>
<p>可有参考《Hive编程指南》一书</p>
<h3 id="4-_CASE…WHEN…THEN_句式">4. CASE…WHEN…THEN 句式</h3><p>CASE…WHEN…THEN语句和if语句类似，用于处理单个列的查询结果。</p>
<pre><code>hive&gt;<span class="keyword">SELECT</span> name, salary,
     <span class="keyword">CASE</span> 
         <span class="keyword">WHEN</span> salary &lt; <span class="number">50000.0</span> <span class="keyword">THEN</span> <span class="comment">'low'</span>
         <span class="keyword">WHEN</span> salary &gt;= <span class="number">50000.0</span> <span class="keyword">AND</span> salary &lt; <span class="number">70000.0</span> <span class="keyword">THEN</span> <span class="comment">'middle'</span>
         <span class="keyword">WHEN</span> salary &gt;= <span class="number">70000.0</span> <span class="keyword">AND</span> salary &lt; <span class="number">100000.0</span> <span class="keyword">THEN</span> <span class="comment">'high'</span>
         <span class="keyword">ELSE</span> <span class="comment">'very high'</span>
     <span class="keyword">END</span> <span class="keyword">AS</span> bracket <span class="keyword">FROM</span> employees;
</code></pre><p>输出结果：</p>
<pre><code>John    <span class="number">100000.0</span>    very high
Todd    <span class="number">70000.0</span>        high
Bill    <span class="number">60000.0</span>      middle
</code></pre><h3 id="5-_什么情况下可以避免MapReduce">5. 什么情况下可以避免MapReduce</h3><pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> employees;</span>
</code></pre><p>此外，如果属性hive.exec.mode.local.auto = true的值为true的话,Hive还会尝试使用本地模式执行其他的操作：</p>
<pre><code><span class="operator"><span class="keyword">set</span> hive.exec.<span class="keyword">mode</span>.<span class="keyword">local</span>.<span class="keyword">auto</span> = <span class="literal">true</span></span>
</code></pre><p>建议将其设置为True</p>
<h3 id="6-_WHERE_查询语句优化">6. WHERE 查询语句优化</h3><pre><code><span class="atom">hive</span>&gt;  <span class="name">SELECT</span> <span class="atom">name</span>, <span class="atom">salary</span>, <span class="atom">deductions</span>[<span class="string">"Federal Taxes"</span>],
       <span class="atom">salary</span> * (<span class="number">1</span>-<span class="atom">deductions</span>[<span class="string">"Fedral Taxes"</span>])
       <span class="name">FROM</span> <span class="atom">employees</span>
       <span class="name">WHERE</span> <span class="atom">round</span>(<span class="atom">salary</span> * (<span class="number">1</span>-<span class="atom">deductions</span>[<span class="string">"Federal Taxes"</span>])) &gt; <span class="number">70000</span>;
</code></pre><p>上面这个查询语句有些啰嗦，“1-deductions[“Fedral Taxes”]”重复出现了2次，下面对其进行优化，注意：WHERE语句中不能出现别名。</p>
<p>改进：</p>
<pre><code>hive&gt; <span class="keyword">SELECT</span> e.* <span class="keyword">FROM</span> 
      (<span class="keyword">SELECT</span> name, salary, deductions[<span class="string">"Federal Taxes"</span>] <span class="keyword">as</span> ded, 
      salary * (<span class="number">1</span>-deductions[<span class="string">"Fedral Taxes"</span>]) <span class="keyword">as</span> salary_minus_fed_taxes 
      <span class="keyword">FROM</span> employees) e
      <span class="keyword">WHERE</span> round(e.salary_minus_fed_taxes) &gt; <span class="number">70000</span>;
</code></pre><h3 id="7-_JOIN_优化">7. JOIN 优化</h3><p>Hive假定查询中最后一个表是最大的那个表，在对每行记录进行连接操作时，它会尝试将其他表缓存起来，然后扫描最后那个表进行计算。因此，用户需要保证连续查询中的表的大小从左到右是依次增加的。</p>
<p>Hive中提供了一个“标记”机制来显式地告诉查询优化器哪张表是大表，使用方法如下：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> <span class="comment">/*+STREAMTABLE(s)*/</span>s.ymd,s.symbol,s.price_close,<span class="keyword">d</span>.dividend 
<span class="keyword">FROM</span> stocks s <span class="keyword">JOIN</span> dividends <span class="keyword">d</span> 
<span class="keyword">ON</span> s.ymd = <span class="keyword">d</span>.ymd <span class="keyword">AND</span> s.symbol = <span class="keyword">d</span>.symbol <span class="keyword">WHERE</span> s.symbol = <span class="string">'AAPL'</span>;</span>
</code></pre><p>Hive 会尝试将表stocks作为驱动表，即使其在查询中不是位于最后面的。</p>
<ol>
<li><p>随机抽样</p>
<p> 我们可以使用rand()函数进行抽样，这个函数会返回一个随机值，前两个查询都返回了两个不相等的值，而第三个查询语句无返回结果。</p>
<pre><code>hive&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> numbers TABLESAMPLE(BUCKET <span class="number">3</span> <span class="keyword">OUT</span> <span class="keyword">OF</span> <span class="number">10</span> <span class="keyword">ON</span> rand()) s;
</code></pre></li>
<li><p>数据块抽样</p>
<p> Hive提供了另外一种按照抽样百分比进行抽样的方式，这种事基于行数的，按照输入路径下的数据块百分比进行的抽样。</p>
<p> 注意：这种抽样方式最小的抽样单元是一个HDFS数据块。因此，如果表的数据大小小于普通的块大小64MB的话，那么将返回所有行。</p>
<pre><code>hive&gt; <span class="function">SELECT * FROM numbersflat <span class="title">TABLESAMPLE</span><span class="params">(<span class="number">0.1</span> PERCENT)</span> s</span>;
</code></pre></li>
</ol>
<h3 id="8-_UNION_ALL">8. UNION ALL</h3><p>UNION ALL 可以将2个或者多个表进行合并，每一个union子查询都必须具有相同的列，而且对应的每个字段的字段类型必须是一致的。例如：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">log</span>.ymd, <span class="keyword">log</span>.<span class="keyword">level</span>, <span class="keyword">log</span>.message
    <span class="keyword">FROM</span> (
        <span class="keyword">SELECT</span> l1.ymd, l1.<span class="keyword">level</span>, l1.message, <span class="string">'Log1'</span> <span class="keyword">AS</span> <span class="keyword">source</span>
    <span class="keyword">FROM</span> log1 l1
<span class="keyword">UNION</span> ALL
    <span class="keyword">SELECT</span> l2.ymd, l2.<span class="keyword">level</span>, l2.message, <span class="string">'Log2'</span> <span class="keyword">AS</span>
<span class="keyword">source</span>
    <span class="keyword">FROM</span> log1 l2
) <span class="keyword">log</span>
<span class="keyword">SORT</span> <span class="keyword">BY</span> <span class="keyword">log</span>.ymd <span class="keyword">ASC</span></span>
</code></pre><p>这里是对同一个源表的数据进行合并，这其实相当于是一个SELECT加上一个WHERE，这个技术可以将一个长的复杂的WHERE语句分割成2个或者多个UNION子查询。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/同步与异步的区别/" itemprop="url">
                  同步与异步的区别(总结)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T10:06:54+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/01/同步与异步的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/01/同步与异步的区别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/01/同步与异步的区别/" class="leancloud_visitors" data-flag-title="同步与异步的区别(总结)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>同步与异步是面试中经常会被问到的问题，特此总结一下：</p>
<h3 id="同步和异步的区别">同步和异步的区别</h3><p>简单而言，同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 </p>
<p>举个例子：普通B/S模式（同步）Ajax技术（异步）</p>
<p>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回（这个期间客户端浏览器不能干任何事）</p>
<p>异步: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p>
<p>线程同步是多个线程同时访问同一资源，等待资源访问结束，浪费时间，效率低    线程异步：访问资源时在空闲等待时同时访问其他资源，实现多线程机制</p>
<p>异步处理就是,你现在问我问题,我可以不回答你,等我用时间了再处理你这个问题.同步不就反之了，同步信息被立即处理 – 直到信息处理完成才返回消息句柄;异步信息收到后将在后台处理一段时间, 而早在信息处理结束前就返回消息句柄</p>
<h3 id="同步、异步、阻塞和非阻塞的概念">同步、异步、阻塞和非阻塞的概念</h3><p>在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。</p>
<h3 id="同步">同步</h3><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p>
<h3 id="异步">异步</h3><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p>
<h3 id="阻塞">阻塞</h3><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p>
<h3 id="非阻塞">非阻塞</h3><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<h3 id="对象的阻塞模式和阻塞函数调用">对象的阻塞模式和阻塞函数调用</h3><p>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>
<h4 id="参考资料：">参考资料：</h4><ol>
<li><a href="http://blog.csdn.net/ohfish/article/details/2948740" target="_blank" rel="external">理解同步与异步</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/进程和线程的区别/" itemprop="url">
                  进程和线程的区别(总结)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T21:29:42+08:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/31/进程和线程的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/31/进程和线程的区别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/31/进程和线程的区别/" class="leancloud_visitors" data-flag-title="进程和线程的区别(总结)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程与线程的区别，应该是互联网公司招聘系统工程师经常会问的一个问题，我查阅了一些相关资料，总结如下：</p>
<h3 id="进程是什么？">进程是什么？</h3><p>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</p>
<p>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<h3 id="有了进程为什么还要线程？">有了进程为什么还要线程？</h3><p>进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p>
<p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。<br>如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p>
<h3 id="线程的优点">线程的优点</h3><p>因为要并发，我们发明了进程，又进一步发明了线程。只不过进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，不过是指令级的并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发！</p>
<p>除了提高进程的并发度，线程还有个好处，就是可以有效地利用多处理器和多核计算机。现在的处理器有个趋势就是朝着多核方向发展，在没有线程之前，多核并不能让一个进程的执行速度提高，原因还是上面所有的两点限制。但如果讲一个进程分解为若干个线程，则可以让不同的线程运行在不同的核上，从而提高了进程的执行速度。</p>
<p>例如：我们经常使用微软的Word进行文字排版，实际上就打开了多个线程。这些线程一个负责显示，一个接受键盘的输入，一个进行存盘等等。这些线程一起运行，让我们感觉到我们输入和屏幕显示同时发生，而不是输入一些字符，过一段时间才能看到显示出来。在我们不经意间，还进行了自动存盘操作。这就是线程给我们带来的方便之处。</p>
<h3 id="进程与线程的区别">进程与线程的区别</h3><ol>
<li><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</p>
</li>
<li><p>线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p>
</li>
</ol>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<h3 id="进程与线程在操作系统设计中的体现">进程与线程在操作系统设计中的体现</h3><p>操作系统的设计，因此可以归结为三点：</p>
<ol>
<li><p>以多进程形式，允许多个任务同时运行；</p>
</li>
<li><p>以多线程形式，允许单个任务分成不同的部分运行；</p>
</li>
<li><p>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>
</li>
</ol>
<p>参考资料：</p>
<ol>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a></p>
</li>
<li><p><a href="http://blog.csdn.net/zengjibing/article/details/3923357" target="_blank" rel="external">进程和线程的区别</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="PengShuang" />
          <p class="site-author-name" itemprop="name">PengShuang</p>
          <p class="site-description motion-element" itemprop="description">在路上，慢慢走！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/pengshuang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2176899852/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lingyu.wang/" title="天镶的博客" target="_blank">天镶的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.dongwm.com" title="小明明的博客" target="_blank">小明明的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PengShuang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pengshuang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("DKbLgBme7UkAx9JX6sM3D4Hj-gzGzoHsz", "GXjJ9Ox3pUGI9PJhm6CNfJGN");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
